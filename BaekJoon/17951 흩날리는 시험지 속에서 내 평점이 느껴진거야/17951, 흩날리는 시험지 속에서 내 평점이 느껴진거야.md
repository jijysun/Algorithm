# 17951, 흩날리는 시험지 속에서 내 평점이 느껴진거야

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/17951)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 256 MB | 3326 | 1621 | 1286 | 51.855% |

## 문제

넓은 시험 범위와 어려운 과제로 유명한 '운영체제로 보는 데이터베이스시스템 알고리즘' 수업은 시험지가 너무 많아 실내에서는 시험을 치를 수 없어서 야외에서 시험을 진행한다. 해당 수업의 수강생인 현수는 오랜 시간에 걸쳐 풀 수 있는 모든 문제를 풀었고 제출만을 남겨두고 있었다. 그러나 갑자기 불어오는 강풍에 현수의 시험지가 모두 날아가 버렸고, 날아간 시험지를 줍는 동안 남은 시간을 다 써버리고 말았다.

시험지에 명시된 규칙 중에는 채점하는 조교의 편의를 위해 시험지를 반드시 순서대로 제출하라는 규칙이 있는데, 이 규칙 때문에 현수는 힘들게 치른 시험이 0점 처리될 위기에 빠지게 되었다!

그러나, 마음씨 좋은 조교인 주찬이는 평소 수업에 열심히 참여한 현수에게 한 번의 기회를 주기로 했다. 규칙은 규칙이므로 많은 점수를 줄 수는 없고, 시험지를 현재 순서 그대로 K개의 그룹으로 나눈 뒤 각각의 그룹에서 맞은 문제 개수의 합을 구하여 그 중 최솟값을 시험 점수로 하기로 하였다. 현수가 이번 시험에서 받을 수 있는 최대 점수를 계산하는 프로그램을 작성하자.

현수는 모르는 문제를 아예 풀지 않기 때문에 현수가 푼 문제는 모두 맞았다고 생각할 수 있으며, 조교는 마음씨가 좋아서 자신이 줄 수 있는 최대한의 점수를 준다.

## 입력

첫 번째 줄에 시험지의 개수 N과 시험지를 나눌 그룹의 수 K가 정수로 주어진다. (1 ≤ K ≤ N ≤ 100,000)

두 번째 줄에 각 시험지마다 맞은 문제의 개수 x가 정수로 주어진다 (0 ≤ x ≤ 20)

## 출력

현수가 받을 수 있는 최대 점수를 출력한다.

---

# 초기 접근 방법

- 두 그룹으로 나누되, 최솟값의 그룹이 중 최대값인 것을 구하는 걸 언급.
- 전체 경우 수는 Combination (N, K) 가 된다.
- 일단 탐색은 필수. 근데 탐색은 어떻게,.,..?
    - 전체 합을 구하되, 차피 시험지 점수 순서는 랜덤으로 이진 탐색?
    - 이진 탐색으로 (전체 합)/N을 통해 넘어가는 경우 스탑?

만약 탐색했는데 그 그룹이 최대가 아닌 경우? 더욱 최대가 있는 경우?

- 현재 순서 그대로 라는 힌트가 있다.

또한 그룹 수 최소 인원을 천천히 늘려가며 순환?

- 

---

# 풀이 과정

- 탐색 알고리즘인 건 얼추 좋은 판단이었으나, 쌩 탐색으로 하는 건 당연히 비효율적이다..

```cpp
#include <algorithm>
#include <iostream>
#include <valarray>
#include <vector>

/**
 * 17951, I felt my rating in the flurry of test papers
 * https://www.acmicpc.net/problem/17951
 */

using namespace std;

int N, K, avg;
vector<int> arr;

void input () {
    cin >> N >> K;

    arr = vector<int>(N);

    for (int i = 0; i<N; i++) {
        cin >> arr[i];
        avg += arr[i];
    }
}

void solution() {
    // K 그룹, + 순서 유지

    vector<int> group;
    // 몫 만큼 , 나머지

    int temp=0;
    for (int i = 1; i<=N; i++) { // 기준 그룹 내 갯수
        printf("-----%d-----\n", i);
        for (int j = 0; j<N; j++) { // 전체 벡터 순환
            int sum=0;
            for (int k = j; k<j+i; k++) { // 벡터 합
                sum += arr[k%N];
            }
            int rest = avg-sum;
            temp = max (temp, min (rest, sum));

            printf("%d ~ %d 범위 결과: %d, %d -> temp = %d\n", j, (j+i)%N-1, sum, rest, temp);
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input ();

    solution();

    return 0;
}
```

- 실패…!

그래서 찾아보니 “이분 탐색”에 대한 알고리즘이었다. 

- 찾고자 하는 값, 최소 중 최대 시험지 값은 그룹이 나누어질 때 총 시험지 합의 중간값과 제일 비슷한 때 이다. → https://mengu.tistory.com/83
- 코드로는 Left, Right을 정하면서 Mid 값을 갱신한다. (START, END 라고 해도 상관은 없다.)
    - 초반 Left, Right을 잘 정하면 더욱 최적화된 이분 탐색을 할 수 있다고 한다.
    - 또한 이 Mid를 통해 Left, Right를 재갱신하며 탐색을 연속한다.
- 갱신된 Mid를 통해 해당 문제의 대한 해답을 찾는 것이다.

```cpp
#include <algorithm>
#include <iostream>
#include <valarray>
#include <vector>

/**
 * 17951, I felt my rating in the flurry of test papers
 * https://www.acmicpc.net/problem/17951
 */

using namespace std;

int N, K, START= 2000000, END;
vector<int> arr;

void input () {
    cin >> N >> K;

    arr = vector<int>(N);

    for (int i = 0; i<N; i++) {
        cin >> arr[i];
        if (START > arr[i]) START = arr[i];
        END += arr[i];
    }
}

void solution(int start, int end) {
    int mid, sum, groupCnt;
    while (start <= end) {
        mid = (start+end)/2, sum=0, groupCnt = 0;

        for (int i = 0; i<N; i++) {
            sum += arr[i];
            if (mid <= sum) { // 그룹을 만들 수 있는 조건 충족!
                sum = 0, groupCnt++;
            }
        }

        printf("start: %d, mid = %d, end: %d  (groupCnt: %d)\n", start, mid, end, groupCnt);

        if (K <= groupCnt) start = mid+1;
        else end = mid-1;
    }

    cout << end << '\n';
}

int main() {
    ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
    input ();
    solution(START, END);
    return 0;
}
```

---

# 결과 & 근거

- 탐색 알고리즘 까지는 접근에 성공했다 ㅎㅎ…
- 어떤 특정 값에 부합하는 탐색 알고리즘이 이분 탐색 알고리즘인 걸 알게 되었다…
- https://uuna-k.tistory.com/entry/BOJ-%EB%B0%B1%EC%A4%80-17951%EB%B2%88-%ED%9D%A9%EB%82%A0%EB%A6%AC%EB%8A%94-%EC%8B%9C%ED%97%98%EC%A7%80-%EC%86%8D%EC%97%90%EC%84%9C-%EB%82%B4-%ED%8F%89%EC%A0%90%EC%9D%B4-%EB%8A%90%EA%BB%B4%EC%A7%84%EA%B1%B0%EC%95%BC-Java