# 2502 떡 먹는 호랑이

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/2502)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 128 MB | 13435 | 6411 | 5207 | 52.788% |

## 문제

하루에 한 번 산을 넘어가는 떡 장사 할머니는 호랑이에게 떡을 주어야 산을 넘어갈 수 있는데, 욕심 많은 호랑이는 어제 받은 떡의 개수와 그저께 받은 떡의 개수를 더한 만큼의 떡을 받아야만 할머니를 무사히 보내 준다고 한다.

예를 들어 첫째 날에 떡을 1개 주었고, 둘째 날에는 떡을 2개 주었다면 셋째 날에는 1+2=3개, 넷째 날에는 2+3=5개, 다섯째 날에는 3+5=8개, 여섯째 날에는 5+8=13개를 주어야만 무사히 산을 넘어갈 수 있다.

우리는 산을 무사히 넘어온 할머니에게 오늘 호랑이에게 몇 개의 떡을 주었는지, 그리고 오늘이 호랑이를 만나 떡을 준지 며칠이 되었는지를 알아내었다. 할머니가 호랑이를 만나서 무사히 넘어온 D째 날에 준 떡의 개수가 K개임을 알 때, 여러분은 할머니가 호랑이를 처음 만난 날에 준 떡의 개수 A, 그리고 그 다음 날에 호랑이에게 준 떡의 개수 B를 계산하는 프로그램을 작성하시오. 이 문제에서는 항상 1 ≤ A ≤ B 이다.

예를 들어 여섯 번째 날에 산을 무사히 넘어온 할머니가 호랑이에게 준 떡이 모두 41개라면, 호랑이를 만난 첫 날에 준 떡의 수는 2개, 둘째 날에 준 떡의 수는 7개이다. 즉 셋째 날에는 9개, 넷째 날에는 16개, 다섯째 날에는 25개, 여섯째 날에는 41개이다. 따라서 A=2, B=7 이 된다. 단 어떤 경우에는 답이 되는 A, B가 하나 이상일 때도 있는데 이 경우에는 그 중 하나만 구해서 출력하면 된다.

## 입력

첫째 줄에는 할머니가 넘어온 날 D (3 ≤ D ≤ 30)와 그 날 호랑이에게 준 떡의 개수 K (10 ≤ K ≤ 100,000)가 하나의 빈칸을 사이에 두고 주어진다.

## 출력

첫줄에 첫 날에 준 떡의 개수 A를 출력하고 그 다음 둘째 줄에는 둘째 날에 준 떡의 개수 B를 출력한다. 이 문제에서 주어진 D, K에 대해서는 항상 정수 A, B (1≤ A ≤ B)가 존재한다.

---

# 초기 접근 방법

문제를 천천히 읽기만 하면 바로 답은 나온다.

- 첫 째날, 둘 째날을 기준으로 점진적으로 증가하는 DP임을 명시해주었다.
- 또한 답도 여려 경우가 있을 수 있으니, 그냥 모든 경우의 수를 검사해주어도 상관 없다는 뜻이다.
    - 전체 데이터 수가 그렇게 큰 편도 아니다.

---

# 풀이 과정

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 * https://www.acmicpc.net/problem/2502
 * tiger, eatting Dduck
 */

int d, k;

vector<pair<int, int>> dp;

void input() {
    cin >> d >> k;

    dp = vector<pair<int,int >>(d);

    dp[0] = {1, 0}, dp[1] = {0, 1};

    for (int i = 2; i<d; i++) {
        dp[i] = {dp[i-1].first+dp[i-2].first ,dp[i-1].second+dp[i-2].second};
    }

    /*for (int i = 0; i<d; i++) {
        printf("dp %d: %d, %d\n",i, dp[i].first, dp[i].second);
    }*/
}

void solution() {
    int first_day = dp[d-1].first, second_day = dp[d-1].second, i = 1;
    while (true) {
        if ((k-first_day*i)%second_day == 0) {
            cout << i << '\n' << (k-first_day*i)/second_day <<'\n';
            break;
        }
        i++;
    }
}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input();

    solution();
}
```

---

# 결과 & 근거

- DP 문제임을 인지하고 손으로 끄적이면서 풀어나갔다.
    - 정확히는 팩토리얼 식이 필요해서 끄적였다.
- 결과는 25분 컷 & 성공.
- 이건 너무 쉬워서 오히려 의심되었던 문제였다.
    - 실버 1 문제이긴 했는데, 엄청 기초라 실버 2여도 될 난이도이다.

### 알고리즘 분류

- 수학
- 다이나믹 프로그래밍
- 브루트포스 알고리즘