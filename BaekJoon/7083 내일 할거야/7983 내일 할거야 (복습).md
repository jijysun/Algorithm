# 7983 내일 할거야 (복습)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/7983)

있잖아. 내가 아까 책상에다가 n개의 과제 목록을 적어놨어. 각각의 과제 i는 di 일이 걸리고, 오늘로부터 ti 일 안에 끝내야 해. 그러니까 오늘이 0일이면, ti일이 끝나기 전에 제출이야. 과제는 한번 시작하면 쉬지 않고 계속해야 해. 안 그러면 머리 아파 지거든.

근데 있잖아. 내가 지금 너무, 너무 아무 것도 안 하고 싶어. 그래서 오늘은 아무 것도 안 할 거야. 더 중요한 게 뭔지 알아? 사실 나 내일도, 모레도, 아무 것도 안 하고 싶어. 한 며칠 동안은 계속 아무 것도 안하려고. 아. 과제가 있을 때 내가 내일부터 연속으로 최대 며칠동안 놀 수 있는지 궁금하다. 궁금하긴 한데, 난 아무 것도 안 하고 싶어.

좋은 생각이 났다. 너희가 이걸 대신 구해주면, 내가 너희의 맞은 문제 수를 하나 올려줄게.

첫째 줄에는 과제의 개수인 정수 n (1 ≤ n ≤ 1,000,000)이 주어진다.

이후 n개의 줄에 각각의 과제를 나타내는 두 정수 di, ti (1 ≤ di, ti ≤ 1,000,000,000)가 순서대로 주어진다. 오늘은 0일이다.

모든 입력에 대해, 오늘 아무 것도 안 해도 과제를 마무리 할 수 있는 방법이 존재함이 보장된다.

내일(1일)부터 연속으로 최대 며칠 동안 놀 수 있는지를 출력한다. 가령, 답이 0이면, 내일 과제를 해야 하며, 1 이면, 모레에 과제를 해야 한다.

---

# 초기 접근 방법

- 조건 안 에서 최대한 많은 일을 연속적으로 놀 수 있어야 한다. 최선의 선택으로 최대 결과를 내야 한다.
    - 그리디 알고리즘?

8, 10, 13 순으로?

2, 3 / 3, 5 / 1 8

- n일의 날짜가 지났을 때, 과제 별 걸리는 날짜가 T(i) 일 이 D(i) 일 보다는 커야 한다.
- 이후 과제를 할 때 마다 이를 누적하면서 T(i) 보다 커야 한다.
- 정렬은 일단 T(i) 순으로..?

---

# 풀이 과정

- 코드
    
    ```cpp
    #include <algorithm>
    #include <iostream>
    
    using namespace std;
    
    int n, d, t;
    int can_play_day = 0; // 오늘 아무 것도 안 해도 과제를 마무리 할 수 있는 방법이 존재함이 보장된다. 오늘은 0일이다.
    pair<int, int> task[1000002];
    
    bool compare(pair<int, int> a, pair<int, int> b) {
        return a.second < b.second;
    }
    
    int main() {
        cin >> n;
    
        for (int i = 0; i < n; i++) {
            cin >> d >> t;
            task[i] = {d, t};
        }
        sort(task, task + n, compare);
        /*for (int i = 0; i < n; i++) {
            printf("%d %d\n", task[i].first, task[i].second);
        }*/
    
        bool cant_play = false;
        while (true) {
            int total_task = 0;
            for (int i = 0; i < n; i++) {
                total_task += task[i].first;
                if (total_task > task[i].second - can_play_day) {
                    // printf("%d 일 동안은 놀 수 없습니다! %d 번 과제 -> %d>%d \n", can_play_day, i,  total_task,task[i].second - can_play_day);
                    cant_play = true;
                    break;
                }
            }
            if (cant_play) {
                break;
            }
            can_play_day++;
        }
    
        cout << can_play_day-1 << '\n';
        return 0;
    }
    
    ```
    
- 1부터 천천히 증가하여 최대로 놀 수 있는 일 수 를 구하였다
- 이는 데이터 갯수로 인해 최악의 데이터 셋의 경우 무조건 시간 복잡도에서 최악을 보여주고, 시간 초과가 걸렸었다.
- 개선 코드
    
    ```cpp
    #include <algorithm>
    #include <iostream>
    
    using namespace std;
    
    int n, d, t;
    int can_play_day; // 오늘 아무 것도 안 해도 과제를 마무리 할 수 있는 방법이 존재함이 보장된다. 오늘은 0일이다.
    pair<int, int> task[1000002];
    
    bool compare (pair<int, int> a, pair<int, int> b) {
        return a.second < b.second;
    }
    
    int main() {
        cin >> n;
    
        for (int i = 0; i < n; i++) {
            cin >> d >> t;
            task[i] = {d, t}; // d일 걸리는 과제가 t일 남았어요!
        }
        sort(task, task + n, compare);
        can_play_day = task[n-1].second - task[n-1].first; // 최대로 놀 수 있게 지정.
    
        for (int i = n-2; i>=0; i--) {
            if (task[i].second < can_play_day) { // 만약 마감일 보다 최대 노는 날이 더 길다면 바꾸기
                can_play_day = task[i].second;
            }
            can_play_day -= task[i].first; // 바꾸고, 과제 일 만큼 빼기
        }
    
        cout << can_play_day << '\n';
        return 0;
    }
    ```
    
- 그냥 날짜 만큼 For 문을 돌리면 되는 것이다.
- 일단 마감일 기준 정렬하되, 뒤에서 부터 반복문을 돌리며, 뒤에서 부터 과제를 시작하는 날짜를 계산한다.
    - 계산 방법은 최대 놀 수 있는 날 보다 마감일이 빠르다면, 마감일로 최대 노는 날을 업데이트 한다
    - 그리고 업데이트 한 최대 노는 날에서 과제 하는 데 걸리는 만큼 빼서 업데이트 한다.

---

# 결과 & 근거

- 시간 초과로 꽤 혼자 하드코딩 했었던 것 같다.
- 그리디 알고리즘 이었고, 모든 경우의 수를 고려해야 한다 생각해서 틀린 코드대로 풀었다.
- 조금만 더 천천히 생각해보자.