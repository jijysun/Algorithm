# 2156 포도주 시식

# 문제 소개

[문제 사이트 링크](https://testcase.ac/problems/2156)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 128 MB | 169821 | 59113 | 43000 | 33.231% |

## 문제

효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

## 입력

첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

## 출력

첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

## 예제

```
6
6
10
13
9
8
1
// -> 33
```

---

# 초기 접근 방법

일렬로 있는 포도주 잔에 대해 최대한 많이 먹을 수 있어야 한다.

- 일렬 → 투 포인터나, 미분 탐색…?
- 근데 어쨌든 조건에 한해 최대한 이라는 키워드가 있어 DP로 풀어보기로 했다.

---

# 풀이 과정

- 간단하게 DP로 풀어보긴 했다.
- cnt로 연속 되는 잔을 표현해보았다.

```cpp
#include <bits/stdc++.h>
using namespace std;

// https://www.acmicpc.net/problem/2156

int graph;
int arr [10002];

void input() {

    cin >> graph;

    for (int i = 0 ; i < graph; i++) {
        cin >> arr[i];
    }

}

void solution() {

    int dp=0, cnt = 0;

    for (int i = 0 ; i<graph-1; i++) { // 첫 번째도 고려해야 할 것 같음.
        if (cnt == 2) {
            cnt = 0;
            continue;
        }

        if (/*cnt ==  &&*/ dp+arr[i] > dp-arr[i]+arr[i+1]) {
            dp+=arr[i], cnt++;
            // printf("더합니다: %d -> dp: %d\n", arr[i], dp);
        }

    }

    // 끝부분 처리
    if (cnt < 2) {
        dp += arr[graph-1];
        printf("더합니다: %d -> dp: %d\n", arr[graph-1], dp);
    }
    cout << dp << '\n';

}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input(), solution();

    /*
     * 포도주 잔: 일렬, 1~n 만큼의 포도주가 들어있음.
     * 1. 마신 후 원래 위치
     * 2. 위치가 연속되는 3잔을 모두 마실 수는 없다.
     * = 가장 많은 포도주를 마셔야 한다.
     */

    /*
     * 생각나는 것: DP, 배낭, 그리디
     *
     * dp [i] = i 잔 까지의 최대 마실 수 있는 포도잔 량 -> max (i-1 까지 다 마심, )
     */

}
```

---

# 결과 & 근거

- 항상 DP나, 그리디 관련 알고리즘을 접할 때 에는 이론적인 접근에서 헤메는 듯 하다.
- 두 잔을 연속해서 선택할 수 없다는 고려 사항이 나한테는 어려웠던 것 같다.
- https://st-lab.tistory.com/135

### 알고리즘 분류

- 다이나믹 프로그래밍