# 20208 진우의 민트초코우유

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/20208)

## 문제

진우는 민트초코우유를 좋아하는 민초단이다. 힘든 일이 있더라도 민트초코우유 하나를 마시면 기운이 펄펄 솟는다고 한다!

민트초코우유를 너무 좋아하는 나머지 진우는 매일 아침 특정 지역들에서 민트초코우유가 배달된다는 *N* × *N* 크기의 2차원 민초마을로 이사를 하였다.

진우는 아침에 눈을 뜨면 집에서 민초마을의 지도를 들고 민트초코우유를 찾으러 출발한다. 이때의 초기 체력은 *M*이다. 여기에서 체력은 진우가 이동할 수 있는 거리를 나타낸다. 진우는 지도상에서 상, 하, 좌, 우로 1칸씩 이동할 수 있으며 이동하면 체력이 1만큼 줄어든다. 진우가 마을을 돌아다니다가 민트초코우유를 마신다면 체력이 *H* 만큼 증가하며 진우의 체력이 초기체력 이상으로 올라갈 수 있다. 체력이 0이 되는 순간 진우는 이동할 수 없다.

민트초코를 찾으러 돌아다니다가 마을 한복판에서 체력이 0이 되어 집으로 못 돌아가는 상황은 만들어져서는 안된다. 진우가 얼마나 많은 민트초코우유를 마시고 집으로 돌아올 수 있는지 알아보자.

입력

첫번째 줄에 민초마을의 크기인 *N*과 진우의 초기체력 *M*, 그리고 민트초코우유를 마실때 마다 증가하는 체력의 양 *H*가 공백을 두고 주어진다. *N*, *M*, *H*는 모두 10보다 작거나 같은 자연수이다.

두번째 줄부터 *N*+1번째 줄에 *N*칸에 걸쳐서 민초마을의 지도가 주어진다. 각 칸은 공백을 두고 주어지며 지도상에서 진우의 집은 1, 민트초코우유는 2로 주어지며 빈 땅은 0으로 주어진다. 진우의 집은 무조건 한 곳이 주어지며 마을에 배달되는 민트초코우유의 총합은 10개를 넘지 않는다.

출력

진우가 집을 나와서 다시 집으로 돌아올 때 까지 마실 수 있는 민트초코우유의 최대 개수를 출력하자

---

# 초기 접근 방법

- 전체적인 그래프가 주어졌고, 모든 가능한 민트초코우유를 먹어야 한다.
    - DFS 이기도 하지만 뭔가 브루트포스와 백트래킹이 필요할 것 같다.

우유 벡터가 있다는 전제 하에

dfs (int x, int y, int hp){

- for 우유 벡터 만큼 순회
    - 해당 우유와의 거리 계산
    - if (hp < 거리)? → continue
    - else if (hp ≥ 거리 && **hp + 우유 ≥ 집**?)
        - 해당 우유 먹기
        - 우유 제거 (2를 0으로 처리, cnt ++)
        - dfs (우유x, 우유y, hp-거리+충전되는량)
    

}

dfs 내부 for 문의 반복 조건

- 벡터 size 가 0이 아닐 때 까지
- 갈 수 있는 우유가 없을 때

---

# 풀이 과정

- 코드
    
    ```cpp
    #include <iostream>
    #include <vector>
    
    using namespace std;
    
    int n, m, h, answer;
    
    int village [11][11];
    vector<pair <int, int>> mint_choco;
    bool visit [11];
    
    pair<int, int> home;
    
    void dfs (int x, int y, int hp, int cnt) {
        bool can_go = false;
        // printf("dfs, 현재 위치: %d,%d, 현재 체력: %d\n", x, y, hp);
    
        for (int i = 0; i<mint_choco.size(); i++) {
            int milk_dist = abs(mint_choco[i].first - x) + abs(mint_choco[i].second-y); // 대각선 처리
            int home_dist = abs(mint_choco[i].first-home.first) + abs(mint_choco[i].second - home.second);
    
            // printf("to (%d,%d): %d, 해당 우유 to 집: %d \n", mint_choco[i].first,mint_choco[i].second, milk_dist, home_dist);
    
            if (hp < milk_dist) continue;
            if (village[mint_choco[i].first][mint_choco[i].second] != 2) continue; // 해당 우유를 먹은 적 없고,
            if (hp >= milk_dist && (hp - milk_dist + h) >= home_dist  ) { // 먹을 수 있는 거리에 있으며, 먹어도 집에 갈 수 있는 경우
    
                // printf("can go to %d,%d !\n--------dfs---------\n", mint_choco[i].first, mint_choco[i].second);
    
                village[mint_choco[i].first][mint_choco[i].second] = -1;
                can_go = true;
                dfs(mint_choco[i].first, mint_choco[i].second, hp-milk_dist+h, cnt+1);
                // village[mint_choco[i].first][mint_choco[i].second] = 2;
            }
        }
        // printf("cant go!");
        if (!can_go) { // 갈수 없었다면 return --
            if (hp >= abs(x-home.first)+abs(y-home.second)) { // 집을 갈 수 있다면?
                // printf("but can go home!\n");
                answer = max (answer, cnt);
                return;
            }
            // cout << printf("현재 위치: %d,%d -> can't go anywhere\n", x, y);
        }
    }
    
    int main() {
        cin >> n >> m >> h;
    
        for (int i = 0; i<n; i++) {
            for (int j =0; j<n; j++) {
                cin >> village[i][j];
                if (village[i][j] == 1) {
                    home.first = i, home.second = j;
                }
                else if (village[i][j] == 2) {
                    mint_choco.push_back({i, j});
                }
            }
        }
    
        // cout << home.first << ", " << home.second << '\n';
    
        dfs(home.first, home.second, m, 0);
    
        cout << answer << endl;
    
        return 0;
    }
    ```
    
- 백트래킹 문제임을 감안하고, DFS 와 함께 Visit 처리를 하는 걸 깜빡해서 혼자 헤맸던 것 같다.
- 결과는 틀렸다.

```cpp
#include <iostream>
#include <vector>

using namespace std;

int n, m, h, answer;

int village [11][11];
vector<pair <int, int>> mint_choco;
bool visit [11];

pair<int, int> home;

void dfs (int x, int y, int hp, int depth) {
    if (hp >= abs(x-home.first) + abs (y-home.second)) {
        answer = max (depth, answer);
    }
    if (depth == mint_choco.size()) return;

    for (int i = 0; i< mint_choco.size(); i++) {
        if (visit[i]) continue;

        int dist = abs (x-mint_choco[i].first) + abs (y-mint_choco[i].second);

        if (hp < dist) continue;

        visit[i] = true;
        dfs(mint_choco[i].first, mint_choco[i].second, hp+h-dist, depth+1);
        visit[i] = false;
    }

}
int main() {
    cin >> n >> m >> h;

    for (int i = 0; i<n; i++) {
        for (int j =0; j<n; j++) {
            cin >> village[i][j];
            if (village[i][j] == 1) {
                home.first = i, home.second = j;
            }
            else if (village[i][j] == 2) {
                mint_choco.push_back({i, j});
            }
        }
    }

    dfs(home.first, home.second, m, 0);

    cout << answer << endl;

    return 0;
}
```

- 기존 Village 를 이용할 필요도 없다
- 그냥 우유만 담은 리스트를 기준으로 반복문을 돌리면서, 해당 민트초코우유까지 갈 수 있는지만 검사하면 되는 것이었다.
- 혼자 하드코딩 했다…

---

# 결과 & 근거

- 참고해서 겨우 풀었다.
- 또한 주어지는 데이터 수가 적어서 DFS 와 다름 없는 코드로 풀 수 있었다.
- 그래도 백트래킹의 원본은 DFS 이고,