# 14864 줄서기 (대실패)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/14864)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 512 MB | 2997 | 1504 | 1096 | 50.670% |

## 문제

N 명의 학생들이 앞뒤로 일렬로 서 있다. 각 학생은 1부터 N까지 서로 다른 번호가 적힌 카드들 중 하나를 가지고 있다. 학생들에게서 자신보다 뒤에 서있으면서 더 작은 번호의 카드를 가진 학생들의 명단을 하나도 빠짐없이 모두 받았다. 이 명단을 통해 학생들이 가지고 있는 카드의 번호를 알아내려고 한다.

예를 들어, 일렬로 서 있는 5명의 학생들을 앞에서부터 순서대로 “학생1, 학생2, 학생3, 학생4, 학생5”라고 하고, 학생들에게 받은 명단을 통해 다음과 같이 5개의 순서쌍이 만들어졌다고 하자. 순서쌍 (X,Y)는 학생Y 가 학생X 보다 뒤에 있으면서 더 작은 번호를 가지고 있다는 것을 의미한다.

`(1,2), (1,5), (3,4), (3,5), (4,5)`

이 자료를 분석하면 학생1, 학생2, 학생3, 학생4, 학생5는 각각 3, 1, 5, 4, 2가 적힌 카드를 가지고 있음을 알 수 있다.

다른 예로 5명 학생들에게 받은 명단으로 다음과 같은 6개의 순서쌍이 만들어 졌다고 하자.

`(1,2), (1,3), (1,5), (2,5), (3,4), (3,5)`

이 경우, 학생들이 잘못된 명단을 제시한 것이다. 순서쌍 (2,5)에 의하면 학생2는 학생5보다 큰 번호의 카드를 가지고 있다. 그런데 만일 학생4의 카드가 학생5의 카드보다 작은 번호라면 순서쌍 (2,4)가 존재해야 하고, 반대로 학생4의 카드가 학생5의 카드보다 큰 번호라면 순서쌍 (4,5)가 존재해야 한다. 그런데 둘 다 존재하지 않기 때문에 학생들이 잘못된 명단을 제시한 것이다.

학생들로부터 받은 명단으로 만들어진 순서쌍을 입력으로 받아, 학생들이 가지고 있는 카드 번호를 알아내는 프로그램을 작성하라.

## 입력

표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학생 수 N (1 ≤ N ≤ 100,000)과 순서쌍의 수 M (0 ≤ M ≤ 1,000,000)이 공백으로 분리되어 주어진다. 일렬로 서 있는 학생들을 순서대로 학생1, 학생2, ... , 학생N 이라고 하자. 다음 M개의 각 줄에는 두 개의 자연수 X와 Y가 공백으로 분리되어 주어진다. 이것은 학생Y가 학생X 보다 더 작은 번호가 적힌 카드를 가지고 있다는 것을 의미하는 순서쌍이다 (1 ≤ X < Y ≤ N). 입력에 중복된 순서쌍은 없다.

## 출력

표준 출력으로, 주어진 순서쌍을 통해 학생들이 가지고 있는 카드 번호를 알 수 있으면 학생들이 서 있는 순서대로 카드번호를 공백으로 분리하여 출력한다. 그렇지 않으면 -1을 출력한다.

## 서브태스크

| 번호 | 배점 | 제한 |
| --- | --- | --- |
| 1 | 7 | N ≤ 9 |
| 2 | 21 | N ≤ 100 |
| 3 | 30 | N ≤ 5,000 |
| 4 | 42 | 원래의 제약조건 이외에 아무 제약조건이 없다. |

## 예제 입력 1

```
5 5
1 2
1 5
3 4
3 5
4 5
-> 3 1 5 4 2
```

## 예제 입력 2

```
5 6
1 2
1 3
1 5
2 5
3 4
3 5
-> -1
```

---

# 초기 접근 방법

- 단순 연결리스트로는 구현이 힘들 것 같다
- 뭔가 DP로 바텀업? 방식이 나은 것 같은데
- 그리디가 있나? -> 그러기엔 입력 수가 너무 많아
    - 논리적인 문제에 더 가까운 느낌

---

# 풀이 과정

- 사실 손도 못댔다…

```cpp

#include <bits/stdc++.h>
using namespace std;
// https://www.acmicpc.net/problem/14864

int n, m;
vector<pair<int,int>> student;

void input() {
    cin >> n >> m;

    for (int i = 0; i < m; i++) {
        pair<int,int> p;
        cin >> p.first >> p.second;
        student.push_back(p);
    }
}

void solution() {

}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
    input();
    solution();

    return 0;
}

```

---

# 결과 & 근거

- 코드적으로는 매우 쉬운 문제이나, 정확히는 “*유추와 가정*”에 대한 문제였다.
    - 어차피 1~N의 학생이 1~N의 번호를 갖고 있다.
    - 그러므로 입력에서 x의 값은 늘리고, y의 값은 줄이는 식으로 작성한다.
    - 또한 같은 등수가 존재하면, 학생에 대한 순서상은 존재하지 않으므로 -1를 출력하고, 존재하는 경우 1차원 배열을 쭉 출력하면 된다.
- 이런 문제는 또 처음 접해봐서 아예 코드에서 손도 대지 못했다…
- https://junseok.tistory.com/239

### 알고리즘 분류

- 수학
- 애드 혹 → https://swdevelop-no1.tistory.com/31
    - 특정 상황에서만 사용 가능한 해결책으로 푸는 알고리즘이라고도 한다.
    - 잘 알려진 정교한 알고리즘을 적용하지 않고 해결할 수 있는 유형의 문제
    - 더 쉽게 말하면 하드코딩, 창의적인 아이디어가 필요한 듯 하다.