# 11442 홀수번째 피보나치 수의 합

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/11442)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 256 MB | 1914 | 1196 | 1107 | 68.545% |

## 문제

피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.

n=17일때 까지 피보나치 수를 써보면 다음과 같다.

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597

n이 주어졌을 때, 0번째 피보나치 수부터 n번째 피보나치 수 중에서 홀수번째 피보나치 수의 합을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 0번째 피보나치 수부터 n번째 피보나치 수 중에서 홀수번째 피보나치 수의 합을 1,000,000,007으로 나눈 나머지를 출력한다.

---

# 초기 접근 방법

- 일단은 문제 헤드라인에서 부터 피보나치 라고 주어주었다.
    - 그렇기에 일단 DP로 빠르게 풀어보고자 한다.
- 또한 입력 값이 매우 매우 크기에 long long 자료형과 매번 나머지를 저장하는 방식을 사용하고자 한다.

---

# 풀이 과정

- 다른 사용하게 될 모든 변수를 long long으로 담고
- dp로 풀었다.

```cpp

#include <bits/stdc++.h>
using namespace std;

long long n; //  1,000,000,000,000,000,000

vector<long long>dp;

void input() {
    cin >> n;

    dp = vector<long long> (n+1);

    dp[0] = 0, dp[1] = 1;
    for (long long i = 2; i<=n; i++) {
        dp [i] = (dp[i-1]+dp[i-2])%1000000007;
    }

}

void solution() {
    long long sum=0;

    for (long long i=1; i<=n; i+=2) { // dp의 홀수만
        sum+=dp[i];
    }

    cout << sum << '\n';
}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
    input();
    solution();
    return 0;
}

```

---

# 결과 & 근거
- 결과는 Bad alloc 런타임 오류가 발생했다.
    - 값이 엄청나게 크기에 계산 도중 오류가 발생한 것으로 보인다.
- 그렇기에 단순 더하는 것 보다, 이 문제에서는 행렬 곱을 사용해서 접근해야 한다..
    - 또한 이런 DP 에 대한 재귀적인 호출이 많을 경우, 필요한 값들을 한 번만 호출해서 접근해야한다.
    - n이 천억까지 가능하므로, 메모이제이션 또한 고려해야 한다.
- https://velog.io/@junttang/BOJ-11444-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98-6-%ED%95%B4%EA%B2%B0-%EC%A0%84%EB%9E%B5-C

### 알고리즘 분류

- 수학
- 분할 정복을 이용한 거듭제곱