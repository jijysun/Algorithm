# 2631 줄세우기 (실패)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/2631)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 128 MB | 16703 | 10790 | 9097 | 66.581% |

## 문제

KOI 어린이집에는 N명의 아이들이 있다. 오늘은 소풍을 가는 날이다. 선생님은 1번부터 N번까지 번호가 적혀있는 번호표를 아이들의 가슴에 붙여주었다. 선생님은 아이들을 효과적으로 보호하기 위해 목적지까지 번호순서대로 일렬로 서서 걸어가도록 하였다. 이동 도중에 보니 아이들의 번호순서가 바뀌었다. 그래서 선생님은 다시 번호 순서대로 줄을 세우기 위해서 아이들의 위치를 옮기려고 한다. 그리고 아이들이 혼란스러워하지 않도록 하기 위해 위치를 옮기는 아이들의 수를 최소로 하려고 한다.

예를 들어, 7명의 아이들이 다음과 같은 순서대로 줄을 서 있다고 하자.

3 7 5 2 6 1 4

아이들을 순서대로 줄을 세우기 위해, 먼저 4번 아이를 7번 아이의 뒤로 옮겨보자. 그러면 다음과 같은 순서가 된다.

3 7 4 5 2 6 1

이제, 7번 아이를 맨 뒤로 옮긴다.

3 4 5 2 6 1 7

다음 1번 아이를 맨 앞으로 옮긴다.

1 3 4 5 2 6 7

마지막으로 2번 아이를 1번 아이의 뒤로 옮기면 번호 순서대로 배치된다.

1 2 3 4 5 6 7

위의 방법으로 모두 4명의 아이를 옮겨 번호 순서대로 줄을 세운다. 위의 예에서 3명의 아이만을 옮겨서는 순서대로 배치할 수가 없다. 따라서, 4명을 옮기는 것이 가장 적은 수의 아이를 옮기는 것이다.

N명의 아이들이 임의의 순서로 줄을 서 있을 때, 번호 순서대로 배치하기 위해 옮겨지는 아이의 최소 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에는 아이들의 수 N이 주어진다. 둘째 줄부터는 1부터 N까지의 숫자가 한 줄에 하나씩 주어진다. N은 2 이상 200 이하의 정수이다.

## 출력

첫째 줄에는 번호 순서대로 줄을 세우는데 옮겨지는 아이들의 최소 수를 출력한다.

---

# 초기 접근 방법

- 이전 값을 확실하게 사용하는 점에 있어 DP로 접근하였다.
    - 뭔가 스왚과 최소라는 점에 있어 그리디나 브루트 포스도 생각해보았다
    - 그래도 이전 값을 활용하는 점이 더욱 커서 DP로 했다.
- 전체적인 수열의 관점에서 보자면 다음과 같은 특징이 있다.
    - 전체적으로 증가하는 수열을 기준으로, 그 수를 고정 시킨다
    - 이후 나머지 값들만 이동하면 된다.
    - 딱히 이동하는 것은 크게 신경 쓰지 않아도 된다는 점이 핵심인 듯 하다.

---

# 풀이 과정

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 * https://www.acmicpc.net/problem/2631
 * line-up
 */

int n; // 2~200

vector<int> kids(201);
int dp[201];

vector<int> answer;

void input() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> kids[i];
    }
}

void solution() {
    /*
     * 스왚을 최소로 하는 알고리즘 (그리디? DP? 브루트포스?)
     * 어쨌든 이전 값을 계속해서 재활용하는 점이 DP?
     *
     * dp [i][j] = i 값을 j 로 옮겼을 때 ?
     * dp[i] = 1번 옮겼을 때의 최소 값? =
     *
     */

    // 근데 스왚 하고 자리 이동은 어떻게? 자료구조를 사용해야 하나?

    // 뭔가 설명하기는 어려운데 그런 느낌
    // 전체적으로 증가하는 수열? 에서
    // 중간에 넣을 수 있는 값이 존재하는 경우 끼워넣기
    // 없는 경우 중간 수열 안에서 불순물 제거하는 느낌으로,.
    /*while (true) {
        for (int i = 0; i < n; i++) {
            // 배열을 순회하면서 제일 길게 증가하는 수열을 어떻게 찾을 것인가? 범위 설정은 어떻게 할 것인가?
            // 이걸 찾는 게 핵심 요건 = 결국 DP 이네
            // 아니 그러면 그냥 한 번만 순회하면 되는 거 아냐?
        }
        break;
    }*/

    for (int j = 0; j<n; j++) {
        int pre = kids[j]; // pre 가 아닌, min 느낌이어야 해.
        dp[j] = 1;
        for (int i = j+1; i < n; i++) {

            if (pre < kids[i]) {
                // 이전 보다는 큰데, 바로 직전 값 보다 큰 경우
                if (kids[i] < kids[i - 1]) {
                    pre = kids[i];
                    dp[i]=dp[i-1];
                }
                else {
                    dp[i] = dp[i - 1] + 1;
                }
            }
            else {
                dp[i]=dp[i-1];
            }
            cout << "dp [" << i << "]: " << dp[i] << '\n';
        }
        cout << n - dp[n-1] << "\n\n\n";
    }
}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
    input();
    solution();
}

```

---

# 결과 & 근거

- 접근은 좋았는데 초반에 너무 헤맸던 것 같다
    - 이전 값을 활용한다는 점에서 DP는 좋았다.
    - 가장 길게 증가하는 수열 (더 정확히는 LIS, 최장 증가 부분 수열)이라는 점의 파악도 좋았다.
- 빠르게 문제를 파악하고, 어떤 알고리즘이 적합할 지 찾는 게 중요한 것 같은데…
    - 시간을 너무 낭비하고, 코드로 소화시키는 것을 잘 못하는 것 같다.

https://velog.io/@bookae/BOJ-2631.-%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0-Java

### 알고리즘 분류

- 다이나믹 프로그래밍