# 2469, 사다리 타기 (성공)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/2469)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 128 MB | 3898 | 1581 | 1257 | 40.653% |

## 문제

k명의 참가자들이 사다리 타기를 통하여 어떤 순서를 결정한다. 참가자들은 알파벳 대문자 첫 k개로 표현되며, 사다리 타기를 시작할 때의 순서는 아래 그림과 같이 항상 알파벳 순서대로이다.

k=10 인 예를 들어 보자. 10명의 A, B, C, D, E, F, G, H, I, J 참가자들이 사다리 타기를 준비한다. 아래 그림은 10개의 세로 줄과 5개의 가로 줄을 가지고 있는 사다리의 한 예를 보여주고 있다.

[](https://upload.acmicpc.net/4fe4986f-aff1-4327-9ce0-a89d8ebeb571/-/preview/)

이 사다리에서 점선은 가로 막대가 없음을, 굵은 가로 실선은 옆으로 건너갈 수 있는 가로 막대가 있음을 나타내고 있다.

따라서 위에 제시된 사다리를 타면 그 최종 도달된 순서는 왼쪽으로부터 A, C, G, B, E, D, J, F, I, H 가 된다.

사다리 타기는 세로 막대를 타고 내려오는 중에 가로막대를 만나면 그 쪽으로 옮겨 가면서 끝까지 내려가는 과정이다.  따라서 사다리 타기의 규칙 특성상 아래 그림과 같이 두 가로 막대가 직접 연결될 수는 없으므로 이 상황은 이 문제에서 고려할 필요가 없다.

[](https://upload.acmicpc.net/58fff896-8c40-4251-9e1b-93c8256beb7c/-/preview/)

**우리는 하나의 가로 줄이 감추어진 사다리를 받아서 그 줄의 각 칸에 가로 막대를 적절히 넣어서 참가자들의 최종 순서가 원하는 순서대로 나오도록 만들려고 한다.**

입력에서 사다리의 전체 모양은 각 줄에 있는 가로 막대의 유무로 표현된다. 각 줄에서 가로 막대가 없는 경우에는 ‘`*`’(별)문자, 있을 경우에는 ‘`-`’(빼기) 문자로 표시된다. 그리고 감추어진 특정 가로 줄은 길이 k-1인 ‘`?`’ (물음표) 문자열로 표시되어 있다.

## 입력

첫 줄에는 참가한 사람의 수 k가 나온다(3 ≤ k ≤ 26). 그 다음 줄에는 가로 막대가 놓일 전체 가로 줄의 수를 나타내는 n이 나온다(3 ≤ n ≤ 1,000). 그리고 세 번째 줄에는 사다리를 타고 난 후 결정된 참가자들의 최종 순서가 길이 k인 대문자 문자열로 들어온다.

k와 n, 그리고 도착순서 문자열이 나타난 다음, 이어지는 n개의 줄에는 앞서 설명한 바와 같이 ‘`*`’와 ‘`-`’ 문자로 이루어진 길이 k-1인 문자열이 주어진다. 그 중 감추어진 가로 줄은 길이가 k-1인 ‘`?`’ 문자열로 표시되어 있다.

## 출력

입력 파일 세 번째 줄에서 지정한 도착순서가 해당 사다리에서 만들어질 수 있도록 감추어진 가로 줄을 구성해야 한다.

여러분은 감추어진 가로 줄의 상태를 재구성하여 이를 ‘`*`’(별) 문자와 ‘`-`’(빼기) 문자로 구성된 길이 k-1인 문자열로 만들어 출력하면 된다.

그런데 어떤 경우에는 그 감추어진 가로 줄을 어떻게 구성해도 원하는 순서를 얻을 수 없는 경우도 있다.  이 경우에는  ‘`x`’(소문자 엑스)로 구성된 길이 k-1인 문자열을 출력해야 한다.

---

# 초기 접근 방법

- 일단 다른 접근 방법은 구상하지는 못했다.

문제 풀이

- 물음표 가로 줄 까지 위에서 내려가고, 아래에서 올라간다.
- 두 문자열에 대한 1대1 비교
    - 같다: previous 값 만 초기화
    다르다: pre 값 초기화 X = 기억,
    - 만약 다음 다른 경우 (달라야 함)
        - 서로의 pre 값이 같다면 ? → 가로화

---

# 풀이 과정

- 문자열에 대한 인덱스 접근이라 조금 복잡했다.
- 위 문제 풀이 방법 그대로 따라가되, 최적화를 진행했다.

```cpp
#include <algorithm>
#include <iostream>
#include <valarray>
#include <vector>

/**
 * 2469, ladder game
 * https://www.acmicpc.net/problem/2469
 */

using namespace std;

int N, K;
int questionMark;
vector<string> arr;
string result;

void input () {
    cin >> N;
    cin >> K;
    cin >>result;

    arr = vector<string>(K);

    for (int i = 0; i<K; i++) {
        cin >> arr[i];
        if (arr[i].at(0) == '?') {
            // printf("?: %d", i);
            questionMark = i;
        }
    }
}

void solution() {

    // Top - down
    vector<char> topDown (N), bottomUp (N);

    for (int i = 0; i<N; i++) {
        int pos = i;
        for (int j = 0; j<questionMark; j++) {
            if (pos-1 >= 0 && arr[j][pos-1] == '-') {
                pos--;
            }
            else if (pos < N && arr[j][pos] == '-') {
                pos++;
            }
        }
        topDown.at(pos) = 65+i;
    }

    for (int i = 0; i<N; i++) {
        int pos = i;
        for (int j = K-1; j>questionMark; j--) {
            if (pos < N && arr[j][pos] == '-') {
                pos++;
            }
            else if (pos-1 >= 0 && arr[j][pos-1] == '-') {
                pos--;
            }
        }
        bottomUp.at(pos) = result[i];
    }

    /*printf("Top-down: ");
    for (char c : topDown) {
        printf("%c", c);
    }
    printf("\n");

    printf("Bottom-up: ");
    for (char c : bottomUp) {
        printf("%c", c);
    }
    printf("\n");*/

    vector<char>ques;
    bool isPreDiff = topDown[0] != bottomUp[0];

    for (int i = 1; i<topDown.size(); i++) {
        if (topDown[i] != bottomUp[i]) {
            if (isPreDiff == true) {
                if ((topDown[i-1] == bottomUp[i]) && (topDown[i] && bottomUp[i-1]) ) {
                    ques.push_back('-');
                    isPreDiff = false;
                }
                else {
                    // printf("return!\n");

                    for (int j = 0; j<topDown.size()-1; j++) {
                        cout << 'x';
                    }
                    cout << '\n';
                    return;
                }
            }
            else {
                ques.push_back('*'), isPreDiff = true;
            }
        }

        else {
            // if (i == 0) continue;
            ques.push_back('*');
        }
    }

    for (char c : ques) {
        cout << c;
    }
    cout << '\n';
}

int main() {
    ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input ();

    solution();

    return 0;
}
```

---

# 결과 & 근거

- 45분 안에 풀지는 못했다… 딱 60분 안에 풀긴 했다. 그리고 한 번에 성공.
- 맨 처음부터 해당 접근 방식을 정확하게 고려하였으나, 뭔가 다른 방법이 있을 거라 생각해서 다른 고민을 하는데 시간을 소모했던 것 같다.
-