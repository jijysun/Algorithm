# 1941 소문난 칠공주

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/1941)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 256 MB | 19777 | 10894 | 7060 | 52.876% |

## 문제

총 25명의 여학생들로 이루어진 여학생반은 5×5의 정사각형 격자 형태로 자리가 배치되었고, 얼마 지나지 않아 이다솜과 임도연이라는 두 학생이 두각을 나타내며 다른 학생들을 휘어잡기 시작했다. 곧 모든 여학생이 ‘이다솜파’와 ‘임도연파’의 두 파로 갈라지게 되었으며, 얼마 지나지 않아 ‘임도연파’가 세력을 확장시키며 ‘이다솜파’를 위협하기 시작했다.

위기의식을 느낀 ‘이다솜파’의 학생들은 과감히 현재의 체제를 포기하고, ‘소문난 칠공주’를 결성하는 것이 유일한 생존 수단임을 깨달았다. ‘소문난 칠공주’는 다음과 같은 규칙을 만족해야 한다.

1. 이름이 이름인 만큼, 7명의 여학생들로 구성되어야 한다.
2. 강한 결속력을 위해, 7명의 자리는 서로 가로나 세로로 반드시 인접해 있어야 한다.
3. 화합과 번영을 위해, 반드시 ‘이다솜파’의 학생들로만 구성될 필요는 없다.
4. 그러나 생존을 위해, ‘이다솜파’가 반드시 우위를 점해야 한다. 따라서 7명의 학생 중 ‘이다솜파’의 학생이 적어도 4명 이상은 반드시 포함되어 있어야 한다.

여학생반의 자리 배치도가 주어졌을 때, ‘소문난 칠공주’를 결성할 수 있는 모든 경우의 수를 구하는 프로그램을 작성하시오.

## 입력

'S'(이다‘솜’파의 학생을 나타냄) 또는 'Y'(임도‘연’파의 학생을 나타냄)을 값으로 갖는 5*5 행렬이 공백 없이 첫째 줄부터 다섯 줄에 걸쳐 주어진다.

## 출력

첫째 줄에 ‘소문난 칠공주’를 결성할 수 있는 모든 경우의 수를 출력한다.

## 예제 1

```
YYYYY
SYSYS
YYYYY
YSYYS
YYYYY
-> 2
```

## 힌트

가능한 방법은 아래와 같다.

```
.....    .....
SYSYS    SYSYS
....Y    .Y...
....S    .S...
.....    .....
```

---

# 초기 접근 방법

- 25명 반에 최대 7명의 ‘이다솜’파를 구하면 되는 것이다.
- 꽤 경우의 수가 적으므로 브루트포스 알고리즘으로 해도, 시간은 넉넉할 듯 하다.
- 아마 조합에 가깝지 않을까?

---

# 풀이 과정

- 변수 및 라이브러리 사용 이유
- 조건부 해석 이유

```cpp
#include <bits/stdc++.h>
using namespace std;
// https://www.acmicpc.net/problem/1941

char classRoom [5][5];

vector<pair<int,int>> v;

void input() {

    for (int i = 0; i<5; i++)
    {
        string s;
        cin >> s;
        for (int j = 0; j<5; j++)
        {
            classRoom[i][j] = s[j];

            if (classRoom[i][j] == 'S') {
                v.push_back(pair<int,int>(i,j));
            }
        }
    }
}

void solution() {

    vector<bool> temp(v.size(), false);

    // 적어도 4명 이상... 잘못 생각했다.

    /*
     * v[0] 냅두기, sum = 0
     * v[1] 부터 고려
     * 만약 x축이 같으면 선분 계산하듯이 계산 sum+= abs(현재 꼭짓점 - 비교 꼭짓점);
     * 만약 달라졌다면? y축 차이 더한 후 현 꼭짓점 갱신 + 반복
     *
     *
     */

    for(int i = 0; i < 4; i ++)
        temp[i] = true;

    do {
        int sum = 0;
        vector<pair<int,int>> com;
        com.push_back(v[0]);
        for (int i = 1; i < v.size(); ++i) {

        }

    } while (prev_permutation(temp.begin(), temp.end()));

}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    /*
     * 여학생반의 자리 배치도가 주어졌을 때, ‘소문난 칠공주’를 결성할 수 있는 모든 경우의 수를 구하는 프로그램을 작성하시오.
     *
     * 경우의 수가 적은 편에 속한다 = 브루트포스가 가능해보인다.
     * 7명의 학생 중 ‘이다솜파’의 학생이 적어도 4명 이상은 반드시 포함되어 있어야 한다. -> 그냥 S 간 조합?
     * 뭔가 그냥 S만 모아놓고 DFS + 백트래킹 -> 라기 보다는 가로 + 세로 이어야 한다. = 가로 세로 간 조합 + 무조건 7명
     *
     */

    /*
     * 풀이 = 2초라 넉넉
     * 1. 입력
     * 2. 입력 도중 S 검색 -> 해당 줄의 가로 세로 모두 경우의 숭에 추가
     * 3. solution -> 모든 조합 검색
     *
     */

    input();
    solution();
}

```

- https://ansohxxn.github.io/algorithm/combination/
- C++의 조합 라이브러리 사용

---

# 결과 & 근거

- 적어도 4명 이상이어야 한다는 것 깜빡했다.
    - 즉 결속력 안에 4명, 5명, 6명, 7명도 경우의 수라는 것이다.
    - 꽤 쉬운 문제라 생각했는데…
- 조합에서 좀 헤맸지만, 결국에는 가로 세로 구현에서 고민하느라 시간을 다 쓴 것 같다.
- 막판에 이론적인 답이 나온 것 같지만, 시간 초과로 나중에 풀고자 한다.
    - pair<int, int> 현재 꼭짓점 = v[0] , sum = 0;
    1. v[1] ~ v[1+비교개수] 비교 
        1. 만약 x축이 같으면? 
            1. 선분 계산하듯이 계산 sum+= abs(현재 꼭짓점 - 비교 꼭짓점);
        2. 만약 달라졌다면? 
            1. y축 차이를 sum에 더하기
        3. 현재 꼭짓점 = v[i]로 갱신
    2. sum = 7이면 답으로 출력할  cnt ++
- https://yabmoons.tistory.com/117
    - 사실 S 기준 그래프 탐색 하면 될 것 같아서 고민했는데, 모든 경우의 수를 구하는 거라 조합으로 풀려고 노력한 것 같다.

### 알고리즘 분류

- 수학
- 그래프 이론
- 브루트포스 알고리즘
- 그래프 탐색
- 조합론
- 너비 우선 탐색
- 백트래킹