# 1111 IQ Test (실패)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/1111)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 128 MB | 18111 | 3937 | 3202 | 22.317% |

## 문제

IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때, 다음 수를 찾는 문제이다.

예를 들어, 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. 약간 더 어려운 문제를 보면, 3, 6, 12, 24, 48이 주어졌을 때, 다음 수는 무엇인가? 역시 답은 96이다.

이제 제일 어려운 문제를 보자.

1, 4, 13, 40이 주어졌을 때, 다음 수는 무엇일까? 답은 121이다. 그 이유는 항상 다음 수는 앞 수*3+1이기 때문이다.

은진이는 위의 3문제를 모두 풀지 못했으므로, 자동으로 풀어주는 프로그램을 작성하기로 했다. 항상 모든 답은 구하는 규칙은 앞 수*a + b이다. 그리고, a와 b는 정수이다.

수 N개가 주어졌을 때, 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 N개의 수가 주어진다. 이 수는 모두 절댓값이 100보다 작거나 같은 정수이다.

## 출력

다음 수를 출력한다. 만약 다음 수가 여러 개일 경우에는 A를 출력하고, 다음 수를 구할 수 없는 경우에는 B를 출력한다.

```
4
-12 12 -36 60

-> num * -2 -12
```

---

# 초기 접근 방법

- 여러 경우가 있지만, 그 중에서 고르는 것이 아닌 해당 되는 것을 모두 찾아야 한다
    - 즉 브루트 포스로 가능한 A와 B를 검색해야한다.
    - 전체 수가 50으로 작아서 브루트포스가 가능해보인다.
- 1차적으로 A, B 성사되는 숫자 검색. (앞 수 *A + B)
    - 일치하면 수열의 공통 패턴이 되는지 따로 검사 로직 (그냥 일일이 검사)

하지만 A와 B를 어떻게 검사…..?

조건문이 매우 많을 것이라 예상하는 데 이게 맞나?

- 감소 or 증가하는 경우
- 음수가 존재하는 경우,
- 첫 번째는 성립, 두 번째 부터 성립하지 않는 경우

1. A와 B에 음수가 섞여있는 지 확인한다.
    - 2, 1, 0, -1 인 경우 A=1, B=-1 이다.
    - 1 -2 3 -4 인 경우 A=-1, B=0 이다.
    - -12 12 -36 60 인 경우 A=-2, B=-12 이다.
    - → 그냥 arr[0] 이랑 arr[1] 이 서로 부호가 다른 경우에 대해 하며 될듯

2. 앞 수 *A는 뒷 수를 넘지 않아야 한다. 넘지 않는 선에서 B를 조정하면서 A와 B 세트를 구해야 한다.

1. 찾은 경우에 대해서 수열의 공통 패턴이 되는 지 검사한다.

---

# 풀이 과정

```java
#include <bits/stdc++.h>
using namespace std;

/*
 * https://www.acmicpc.net/problem/1111
 * IQ Test
 */

int n;
int arr[51]; // -100 ~ 100
bool ret = false;
pair<int, int > p;

void input() {
    cin >> n;
    for (int i = 0; i<n; i++) {
        cin >> arr[i];
    }
}

void solution() {

    int a = 1;
    int b = 0;
    while (arr[0] * a <= arr[1]) {
        b = arr[1] - arr[0]*a;
        if (arr[1]*a+b == arr[2]) {

            if (ret) {
                cout << "A" << '\n';
                return;
            }

            ret = true;
            p = {a, b};
            cout << "a: " << a << ", b: " << b << '\n';
        }
        a++;
    }

    a = -1, b=0;
    while (arr[0]*a <= arr[1]) {
        b = arr[1] - arr[0]*a;
        if (arr[1]*a+b == arr[2]) {

            if (ret) {
                cout << "A" << '\n';
                return;
            }

            ret = true;
            p = {a, b};
            cout << "a: " << a << ", b: " << b << '\n';
        }
        a--;
    }

    cout << arr[n-1]*p.first + p.second;

}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
    input();
    solution();
}
```

---

# 결과 & 근거

- 완전히 코드적으로도 접근하지 못했다.
    - 단순 구현으로 가능한 지에 대해서도 확인이 서지 않았다.
- 결과적으로는 브루트포스? 이긴 하나 단순 조건을 통한 구현에 더 가까웠던 것 같다.

https://dmzld.tistory.com/15

- 항상 보면 간단하게 생각해보면 될 것들인데, 하드 코딩, 하드 띵킹 하는 것 같다.

### 알고리즘 분류

- 수학
- 구현
- 브루트포스 알고리즘
- 많은 조건 분기