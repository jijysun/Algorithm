# 11562 백양로 브레이크

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/11562)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 256 MB | 4505 | 2293 | 1755 | 48.899% |

## 문제

서울 소재 Y모 대학교에서 대규모 공사를 진행하면서, 학교가 마치 미로처럼 변해버리고 말았다. 공사 이전까지는 어떤 건물에서 출발하더라도 다른 모든 건물로 갈 수 있는 길이 있었으나, 공사가 진행되면서 어떻게 한 건진 알 수 없지만 일방통행만 가능한 길이 많이 늘고 말았다.

컴퓨터과학과 학생 남규는 전공 수업을 듣고 교양 수업을 들으러 가던 중 길을 잃어 3일 밤낮을 헤매다가 공학관에서 종합관으로 가는 길은 존재하지 않는다는 결론을 내렸다.

3일 사이에 과제도 내지 못하고 출석도 하지 못해 학사경고 위기에 처한 남규는 전공을 살려 현재 일방통행인 길들 중 반드시 양방향으로 바꿔야만 하는 길이 몇 개인지 조사해 학교에 건의하기로 마음을 먹었다.

남규는 여러 건물들 사이를 직접 잇는 길들을 모두 조사했고, 그 중 어떤 길들이 일방통행인지, 또는 양방향 통행이 가능한지를 모두 체크했다.

남규의 프로그램은 간단하다. 출발지와 도착지를 입력하면 도착지까지 가기 위해 최소 몇 개의 길을 양방향으로 바꿔야만 하는지를 출력해준다. 프로그램이 완성되었다는 소문이 퍼지자, 남규처럼 길을 잃고 헤맨 경험이 있는 학생들은 남규에게 묻기 시작했다.

"공학관에서 대강당 갈 수 있어?"

"상경대 별관에서 학관으로는?"

남규는 매번 손으로 타이핑해 입력하고 결과를 보내주는 데에 지치고 말았다.

결국 앓아누운 남규를 위해 학생들의 질문을 해결할 새로운 프로그램을 만들어보자.

## 입력

첫 줄에 Y대학교 건물의 수 n과 길의 수 m이 주어진다. (n ≤ 250, m ≤ n * (n - 1) / 2 )

다음 m줄에 걸쳐, u v b (1 ≤ u ≤ n, 1 ≤ v ≤ n, u != v, b = 0 또는 1) 의 형태로 길에 대한 정보가 주어진다.

b가 0일 경우 u에서 v로 가는 일방통행 길인 것이고, b가 1일 경우 u와 v를 잇는 양방향 길이다.

어떤 두 건물 사이를 잇는 길은 최대 한 개이다.

다음 줄에 학생들의 질문의 수 k가 주어진다. (1 ≤ k ≤ 30,000)

다음 k줄에 걸쳐 s e (1 ≤ s ≤ n, 1 ≤ e ≤ n)의 형태로 학생들의 질문들이 주어진다.

이는 질문한 학생이 건물 s에서 건물 e로 가고 싶다는 의미이다.

## 출력

출력은 k줄에 걸쳐 이루어진다.

각 질문에 대해, 최소 몇 개의 일방통행인 길을 양방향 통행으로 바꿔야 출발지에서 도착지로 갈 수 있는지를 출력한다.

모든 길을 양방향으로 바꾸더라도 서로 도달 불가능한 건물은 없다.

---

# 초기 접근 방법

일방통행만 가능 → 그 길 중에서 무조건 양방향으로 바꿔야 하는 길을 조사 및 변경

- 양방향 길 최소 전환 횟수

일단 건물이 나열되고, 건물의 길에 따라 방향, 무방향으로 연결된다.

- 그래프 처럼 건물 간 연결 관계가 나오므로 DFS로 해결
- DFS 로 순환하되, 목표 건물으로의 길이 양방향이 아닌 경우, ++
- 목표물을 찾는 순간 답 리스트에 추가

---

# 풀이 과정

- DFS 로 푼 결과 → 틀림
    
    ```cpp
    #include <algorithm>
    #include <iostream>
    #include <valarray>
    #include <vector>
    
    /**
     * 11562, Baegyang-ro Break
     * https://www.acmicpc.net/problem/11562
     */
    
    using namespace std;
    
    int n, m, k;
    
    vector<int> result;
    vector<vector<int>> graph;
    int two_way [252][252] = {0}; // 일방통행 인 경우 1
    bool visit[251], find_result = false;
    vector<pair<int, int>> ques;
    
    int one_way_cnt=0, dest;
    
    void input () {
        cin >> n >> m;
    
        graph = vector<vector<int>> (n+1); // 1부터 순회!
    
        int u, v, b;
        for (int i =0; i<m; i++) {
            cin >> u >>  v >> b;
    
            graph[u].push_back(v), graph[v].push_back(u);
            if (b == 1) {
                two_way[u][v] = 1; // 일방통행 인 경우 1
                two_way[v][u] = 1; // 일방통행 인 경우 1
            }
            two_way[u][v] = 1;
            /*else {
                two_way[u][v] = 1;
                two_way[v][u] = 0;
            }*/
        }
    
        cin >> k;
    
        int s, e;
        for (int i = 0; i<k; i++) {
            cin >> s >> e;
            ques.push_back({s, e});
        }
    }
    
    void dfs(int start) {
        visit[start] = true;
        printf ("%d, ", start);
        for (int i = 0; i < graph[start].size(); i++) {
            if (find_result) {
                return;
            }
            if (graph[start][i] == dest) {
                if (two_way[start][graph[start][i]] == 0) { // 일방통행 인 경우 1
                    printf("일방 통행 ->");
                    one_way_cnt++;
                }
                printf("find!");
                find_result = true, result.push_back(one_way_cnt);
                return;
            }
    
            if (!find_result && !visit[graph[start][i]]) {
                if (two_way[start][graph[start][i]] == 0) {
                    // 일방통행 인 경우 1
                    printf("일방 통행 -> ");
                    one_way_cnt++;
                    visit[graph[start][i]] = true;
                    dfs(graph[start][i]);
                    one_way_cnt--;
                }
                else {
                    visit[graph[start][i]] = true;
                    dfs(graph[start][i]);
                }
            }
        }
    }
    
    void dfs2(int start) {
        printf ("%d, ", start);
        for (int i = 0; i < graph[start].size(); i++) {
            /*if (find_result) {
                return;
            }
            if (graph[start][i] == dest) {
                if (two_way[start][i] == 0) { // 일방통행 인 경우 1
                    printf("일방 통행 입니다.");
                    one_way_cnt++;
                }
                printf("find!");
                find_result = true;
                return;
            }*/
    
            if (/*!find_result && */ !visit[graph[start][i]]) {
                if (two_way[start][i] == 0) {
                    // 일방통행 인 경우 1
                    one_way_cnt++;
                    visit[graph[start][i]] = true;
                    dfs(visit[graph[start][i]]);
                    one_way_cnt--;
                }
                else {
                    visit[graph[start][i]] = true;
                    dfs(graph[start][i]);
                }
            }
        }
    }
    
    void solution() {
        for (pair<int, int> q : ques) {
            // dfs 를 조집시다
            if (q.first == q.second) {
                result.push_back(0);
            }
            else {
                dest = q.second;
                dfs(q.first);
                printf("\n");
    
                // result.push_back(one_way_cnt);
    
                for (int i =0; i<251; i++) {
                    visit[i] = false;
                }
            }
    
            printf("%d -> %d = %d\n\n", q.first, q.second, one_way_cnt);
            one_way_cnt = 0, find_result = false;;
        }
    }
    
    int main() {
        ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
    
        input ();
    
        solution();
    
        for (int i : result) {
            cout << i << '\n';
        }
    
        return 0;
    }
    ```
    

---

# 결과 & 근거

- 단순 연결 그래프에서 순환하면서 목적지를 찾으면 될 것 같아서 DFS로 했다.
- 하지만 문제는 “목적지로 가는 길 중 단방향 최소 전환 수” 이다.
- 또한 모든 노드 간 최단 경로를 구하면서 단방향을 전환해야 한다.
    - 즉 DFS는 최단 경로 알고리즘에는 속하지 않는다.
    - 찾아본  결과, 플로이드 워셜 알고리즘이 해당 문제의 해답이다.
    

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, M, K, ans, dist[251][251];

void input () {
    cin >> N >> M;
    // dist 배열 초기화
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            dist[i][j] = i == j ? 0 : 50000;
        }
    }

    // 간선 입력
    for (int i = 1; i <= M; i++) {
        int u, v, b;
        cin >> u >> v >> b;
        // 이 간선을 지나는 경로가 최단거리일 경우 양방향으로 바꿀 필요가 없다
        dist[u][v] = 0;
        // 양방향이면 dist[v][u]도 0
        dist[v][u] = b ? 0 : 1;
    }
}

void solution () {
    // 플로이드 워셜
    for (int k = 1; k <= N; k++)
        for (int i = 1; i <= N; i++)
            for (int j = 1; j <= N; j++)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
    cin >> K;
    while (K--) {
        int s, e;
        cin >> s >> e;
        cout << dist[s][e] << '\n';
    }
}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input ();
    
    solution();

}
```