# 4256 트리 (복습)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/4256)

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 노드의 개수 n이 주어진다. (1 ≤ n ≤ 1,000) BT의 모든 노드에는 1부터 n까지 서로 다른 번호가 매겨져 있다. 다음 줄에는 BT를 전위 순회한 결과, 그 다음 줄에는 중위 순회한 결과가 주어진다. 항상 두 순회 결과로 유일한 이진 트리가 만들어지는 경우만 입력으로 주어진다.

## 출력

각 테스트 케이스마다 후위 순회한 결과를 출력 한다.

---

# 초기 접근 방법

- 후순위 순회, 후위 순회는 Left_Child, Right_Child, Parent 이런 식으로 순회한다
    - 충분히 DFS 로 구현가능하다.
- 하지만 해당 문제는 전위 순회, 중위 순회의 결과가 주어진다
    - 이를 통해 먼저 구조가 정해진 트리를 구성해야 한다.
    - 그렇기에 정해진 후위 순회 결과를 도출해내야 한다.

문자열 파싱하듯이 생각하면 쉽다

- 전위 순회 같은 경우 Parent, Left_Child, Right_Child 방식으로 순회한다
    - (전체 노드 개수 -1) 를 좌측 부분 트리, 우측 서브 트리로 나누고 각자 배분한다 생각하면 된다.
    - 예제의 3 6 5 4 8 7 1 2 같은 경우, P는 3 이고, [6 5 4 8 7 1 2] 가 서브 트리가 되겠다.
- 중위 순회 같은 경우 Left_Child, Parent,  Right_Child 방식으로 순회한다.
    - 동일 예제의 5 6 8 4 3 1 2 7 의 경우, 
    중간에 위치한 루트 3을 제외 양 쪽의 부분 트리가 [5 6 8 4],  [1 2 7]가 되겠다.
    - 또한 양 서브 트리에서 {왼쪽 자식이 순서가 먼저이다.} 라는 정보를 통해
        - 남은 노드 개수가 짝수인 경우 2번째 노드가 루트가 되겠다.
- 그렇기에 전위 순회를 통해 루트 노드를, 중위 순회를 통해 양 쪽의 부분 트리와 각 노드 위치를 파악하면 되겠다.

---

# 풀이 과정

```cpp
#include <algorithm>
#include <iostream>

using namespace std;

int t;
int n;

int pre_tree[1001];
int in_tree[1001];

void get_tree (int left, int right, int index) {

    // index는 다음으로 찾을 루트의 좌표.

    for (int i = left; i<right; i++) { // 순서대로 루트 찾기.
        if ( pre_tree[index] == in_tree[i]) { // 루트를 찾았다면?

            // 좌측 서브 트리 다음 루트는 현 루트에서 차례대로 증가한 값.
            get_tree(left, i, index+1);

            // 우측 서브 트리 다음 루트는 현 루트에서 왼족 서브트리 개수 만큼 건너뛴 값.
            get_tree(i+1, right, index-left+i+1);

            cout << pre_tree[index] << ' ';
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    cin >> t;

    for (int i = 0; i < t; i++) {
        cin >> n;
        for (int j = 0; j < n; j++) {
            cin >> pre_tree[j];
        }
        for (int j = 0; j < n; j++) {
            cin >> in_tree[j];
        }
        get_tree(0, n,0);
        cout << '\n';
    }

    return 0;
}
```

---

# 결과 & 근거

- 이론적 접근과 코딩 까지는 좋았으나, 인덱싱에서 너무나도 헤맸다…
-