# 14718 용감한 용사 진수

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/14718)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 256 MB | 1667 | 674 | 526 | 45.150% |

## 문제

N명의 적 병사가 있다. 적의 각 병사는 힘, 민첩, 지능의 3가지 능력치를 가진다. 용감한 용사 진수도 힘, 민첩, 지능의 3가지 능력치를 가진다.

적의 각 병사에 대해,

1. 적 병사가 가진 힘보다 진수의 힘이 크거나 같고,
2. 적 병사가 가진 민첩보다 진수의 민첩이 크거나 같고,
3. 적 병사가 가진 지능보다 진수의 지능이 크거나 같으면,

진수는 그 적 병사를 이길 수 있다.

용감한 용사 진수에게 스탯 포인트를 주면 똑똑한 진수는 자기가 최대한 많은 적을 이길 수 있도록 스탯 포인트를 스스로 분배한다.

N명의 병사들 스탯이 주어졌을 때, 진수가 적어도 K명의 병사를 이길 수 있게 하는 최소의 스탯 포인트를 구하여라.

## 입력

첫 번째 줄에는 N명의 병사 수와 용감한 용사 진수가 이겨야 할 K명의 병사 수가 주어진다. (1 ≤ K ≤ N ≤ 100)

두 번째 줄부터 N+1 번째 줄까지 각 줄마다 병사들의 힘, 민첩, 지능을 세 개의 음이 아닌 정수로 주어진다. (0 ≤ 힘, 민첩, 지능 ≤ 1000000)

## 출력

용감한 용사 진수가 적어도 K명의 병사를 이길 수 있게 하는 최소의 스탯 포인트를 출력하여라.

---

# 초기 접근 방법

이기는 방법: 진수가 힘, 민첩, 지능 모두 상대 병사보다 크거나 같아야 한다.

- 스탯을 골고루, 효율적으로 분배해야 한다.
- 또한 N명의 병사 중 적어도 K는 이기는 최소 스탯 중 최대.

1. 만약 N == K 인 경우
    - 진수는 모든 스탯에 대해 다른 병사를 모두 이겨야 한다.
    - 즉 힘, 민첩, 지능 모두 최대
2. 

---

# 풀이 과정

- 문제의 관건?
    - 스탯의 분배
    - 분배된 스탯에 대한 이길 수 있는 병사 cnt

예상 풀이

- 입력 → 중간 스탯에서 스타트.
- 입력 받은 병사 sort() ?

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 * https://www.acmicpc.net/problem/14718
 * brave solder jinsu
 */

class soldier {
public:
    int str=0, dex=0, smart=0;

public:
    int sum () {
        return this->str + this->dex + this->smart;
    }
};

int n, k;

int str_max=0, dex_max=0, smart_max=0;
vector<soldier> soldierList;

bool compare (soldier s1, soldier s2) {
    /*if (s1.str == s2.str) {
        if (s1.dex == s2.dex) {
            return s1.smart < s2.smart;
        }
        return s1.dex < s2.dex;
    }
    return  s1.str < s2.str;*/

    return  s1.str+ s1.dex+ s1.smart< s2.str+ s2.dex+ s2.smart; // 총합 낮은 순으로 ;
}

void input() {
    cin >> n >> k;

    for (int i = 0; i<n; i++) {
        soldier s;
        cin >> s.str >> s.dex >> s.smart;
        soldierList.push_back(s);

        str_max = max(str_max, s.str);
        dex_max = max(dex_max, s.dex);
        smart_max = max(smart_max, s.smart);
    }
}
int sum (int a, int b, int c) {
    return a+ b+ c;
}

void solution() {

    if (n == k) {
        cout << str_max + dex_max + smart_max << '\n';
        return;
    }

    // 정렬 -> 학생은 100명 밖에 안되므로,

    sort(soldierList.begin(), soldierList.end(), compare);

    /*for (soldier s1 :soldierList) {
        printf("solder: %d, %d, %d\n", s1.str, s1.dex, s1.smart);
    }*/

    // 중간에서 스타트
    // stat을 어떻게...?

    // int s_max=0, d_max = 0, i_max=0;
    vector<int> stat = vector<int>(3);
    for (int i = 0; i<k; i++) {

        // printf("%d, %d\n",soldierList[i].sum(), soldierList[i+1].sum());
        if (soldierList[i].sum() == soldierList[i+1].sum()) { // 스탯이 전부 동일할 떄
            int index = min_element(stat.begin(), stat.end())-stat.begin();

            // 그들 중 이길 수 있는 애를.
            switch (index) {
                case 0:
                    if (stat[index]> soldierList[i].str) {
                        stat[0] = max(stat[0], soldierList[i+1].str);
                        stat[1] = max(stat[1], soldierList[i+1].dex);
                        stat[2] = max(stat[2], soldierList[i+1].smart);
                    }
                    else {
                        stat[0] = max(stat[0], soldierList[i].str);
                        stat[1] = max(stat[1], soldierList[i].dex);
                        stat[2] = max(stat[2], soldierList[i].smart);
                    }
                    break;
                case 1:
                    if (stat[index]> soldierList[i].dex) {
                        stat[0] = max(stat[0], soldierList[i+1].str);
                        stat[1] = max(stat[1], soldierList[i+1].dex);
                        stat[2] = max(stat[2], soldierList[i+1].smart);
                    }
                    else {
                        stat[0] = max(stat[0], soldierList[i].str);
                        stat[1] = max(stat[1], soldierList[i].dex);
                        stat[2] = max(stat[2], soldierList[i].smart);
                    }
                    break;
                case 2:
                    if (stat[index]> soldierList[i].smart) {
                        stat[0] = max(stat[0], soldierList[i+1].str);
                        stat[1] = max(stat[1], soldierList[i+1].dex);
                        stat[2] = max(stat[2], soldierList[i+1].smart);
                    }
                    else {
                        stat[0] = max(stat[0], soldierList[i].str);
                        stat[1] = max(stat[1], soldierList[i].dex);
                        stat[2] = max(stat[2], soldierList[i].smart);
                    }
                    break;
                default:
                    printf("error\n");
                break;
            }
            continue;
        }

        stat[0] = max(stat[0], soldierList[i].str);
        stat[1] = max(stat[1], soldierList[i].dex);
        stat[2] = max(stat[2], soldierList[i].smart);
    }

    // printf("이길려면 %d, %d, %d -> %d 이어야 합니다\n", s_max, d_max, i_max, s_max+d_max+i_max);

    // 어떻게 스탯
    cout << stat[0]+stat[1]+stat[2] << '\n';
}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input();

    solution();
}
```

---

# 결과 & 근거

- 브루트 포스라는 접근은 좋았다. 근데 완전 탐색을 하지 않은 점이다…!
- 완전 탐색이라는 기준을 두고 풀면 엄청 쉬운 문제이다… 왜 이렇게 하드 코딩 하는 것일까?
- https://ddb8036631.github.io/boj/14718_%EC%9A%A9%EA%B0%90%ED%95%9C-%EC%9A%A9%EC%82%AC-%EC%A7%84%EC%88%98/