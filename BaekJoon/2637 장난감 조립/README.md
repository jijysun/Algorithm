# 2637 장난감 조립

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/2637)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 128 MB | 11098 | 5265 | 3908 | 50.491% |

## 문제

우리는 어떤 장난감을 여러 가지 부품으로 조립하여 만들려고 한다. 이 장난감을 만드는데는 기본 부품과 그 기본 부품으로 조립하여 만든 중간 부품이 사용된다. 기본 부품은 다른 부품을 사용하여 조립될 수 없는 부품이다. 중간 부품은 또 다른 중간 부품이나 기본 부품을 이용하여 만들어지는 부품이다.

예를 들어보자. 기본 부품으로서 1, 2, 3, 4가 있다. 중간 부품 5는 2개의 기본 부품 1과 2개의 기본 부품 2로 만들어진다. 그리고 중간 부품 6은 2개의 중간 부품 5, 3개의 기본 부품 3과 4개의 기본 부품 4로 만들어진다. 마지막으로 장난감 완제품 7은 2개의 중간 부품 5, 3개의 중간 부품 6과 5개의 기본 부품 4로 만들어진다. 이런 경우에 장난감 완제품 7을 만드는데 필요한 기본 부품의 개수는 1번 16개, 2번 16개, 3번 9개, 4번 17개이다.

이와 같이 어떤 장난감 완제품과 그에 필요한 부품들 사이의 관계가 주어져 있을 때 하나의 장난감 완제품을 조립하기 위하여 필요한 기본 부품의 종류별 개수를 계산하는 프로그램을 작성하시오.

## 입력

첫째 줄에는 자연수 N(3 ≤ N ≤ 100)이 주어지는데, 1부터 N-1까지는 기본 부품이나 중간 부품의 번호를 나타내고, N은 완제품의 번호를 나타낸다. 그리고 그 다음 줄에는 자연수 M(3 ≤ M ≤ 100)이 주어지고, 그 다음 M개의 줄에는 어떤 부품을 완성하는데 필요한 부품들 간의 관계가 3개의 자연수 X, Y, K로 주어진다. 이 뜻은 "중간 부품이나 완제품 X를 만드는데 중간 부품 혹은 기본 부품 Y가 K개 필요하다"는 뜻이다. 두 중간 부품이 서로를 필요로 하는 경우가 없다.

## 출력

하나의 완제품을 조립하는데 필요한 기본 부품의 수를 한 줄에 하나씩 출력하되(중간 부품은 출력하지 않음), 반드시 기본 부품의 번호가 작은 것부터 큰 순서가 되도록 한다. 각 줄에는 기본 부품의 번호와 소요 개수를 출력한다.

정답은 2,147,483,647 이하이다.

## 예제 입력 1

```
7
8
5 1 2
5 2 2
7 5 2
6 5 2
6 3 3
6 4 4
7 6 3
7 4 5

```

## 예제 출력 1

```
1 16
2 16
3 9
4 17
```

---

# 초기 접근 방법

- 재귀적인 느낌이 들어 뭔가 특정 알고리즘 방법이 생각나지 않았다.
- 트리 처럼, 하위 노드가 존재할 경우 재귀로 내려가는 방식으로 총 필요한 갯수를 구하고자 한다.

---

# 풀이 과정

```cpp

#include <bits/stdc++.h>
using namespace std;
// https://www.acmicpc.net/problem/2637

int n, m;

vector<vector<pair<int, int>>> graph, custom;
vector<pair<int, int>> complete;

int complete2 [101] ;

void input() {
    cin >> n >> m;

    graph.resize(n+2);
    custom.resize(n+2);

    int num, peace, cnt;
    for (int i = 0; i < m; i++) {
        cin >> num >> peace >> cnt;

        graph[num].push_back(make_pair(peace, cnt));

        if (num == n) {
            complete.push_back(pair<int, int>(peace, cnt));
        }
    }
}

void create(int piece, int cnt) {

    /*
     * 최적화 필요
     */

    // 약간 경로 압축 마냥, map 같은 느낌이 필요해

    /*if (!custom[piece].empty()) {
        for (pair<int, int> p : custom[piece]) {

        }
        return;
    }*/

    if (graph[piece].empty()){
        // cout << piece << "을 " << cnt << "만큼 증가시킵니다" << endl;
        complete2[piece] += cnt;
        custom[piece].push_back(make_pair(piece, cnt));
    }
    else
    {
        for (pair<int, int> p : graph[piece])
        {
            create(p.first, p.second * cnt);
        }
    }
}

void solution() {

    for (pair<int, int> p : complete) {

        // 함수 호출
        create(p.first, p.second);

        // 리스트 ++?
    }
    /*for (int i = 1; i <= n; i++) {
        cout << i << ": " << complete2[i] << "개" << endl;
    }*/

    for (int i = 1 ; i<=n; i++) {
        if (complete2[i]!= 0)
        {
            cout << i << " " <<complete2[i] << "\n";
        }
    }

    // 맵 느낌 나는데 어떻게 맵 당 요소를 2개?
    //

    // 완제품 조합 요소만 담아두고, 나머지는 map으로?

    /*
     * 7 조합 만큼 for문
     * - 내부 요소 꺼냄
     * - 조회 번호가 하위 요소를 갖을 경우, 총 갯수 *= 갯수
     *      - 재귀 호출이 필요하다.
     *      - 트리 느낌ㅁ
     * - 조회 번호에 대한 벡터 길이가 0 일 경우 답에 추가.
     *
     *
     */
}

int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    input();
    solution();

    /*
     *
     * 총 완제품을 만드는 데 필요한 기본 부품 개수.
     *
     */

    return 0;
}

```

---

# 결과 & 근거

- 1초도 넉넉해서 좀 위험할 수 있는 재귀호출 (DFS 느낌)로 풀었더니 시간 초과가 발생했다.
- 그래서 중간에 memorization으로 최적화를 하다가 시간 내로 풀지 못했다.
- 정확한 풀이는 다이나믹 프로그래밍과 위상 정렬
    - 각 계층, 차수가 존재하여 이를 나는 재귀호출로 풀어서 시간 초과가 발생한 듯 하다.
    - 위상 정렬은 잘 안접했던 개념이라 헷갈린 것도 없지 않아 있다.
- https://jun-n.tistory.com/188
- Gemini의 설명
    
    백준 2637번 '장난감 조립' 문제는 전형적인 **DAG(Directed Acyclic Graph, 방향성 비순환 그래프)** 구조를 가지고 있습니다. 작성하신 코드의 방식과 위상 정렬(Topological Sort) 방식의 결정적인 차이점을 짚어드릴게요.
    
    ---
    
    ## 1. 왜 이 문제가 '위상 정렬' 문제인가요?
    
    이 문제의 핵심은 **"어떤 부품을 만들기 위해 필요한 하위 부품들이 먼저 계산되어 있어야 한다"**는 것입니다.
    
    ### 의존 관계의 순서
    
    예를 들어, 7번 완제품을 만드는데 5번과 6번이 필요하고, 5번을 만드는 데 1, 2번 부품이 필요하다고 가정해 봅시다.
    
    - **작성하신 코드(재귀/DFS):** 7번부터 시작해서 아래로 내려가며 중복해서 계산합니다. (이미 계산한 부품도 다시 방문하게 됨)
    - **위상 정렬:** 진입 차수(Indegree)가 0인 부품(기본 부품)부터 시작해서, 상위 부품으로 올라가며 필요한 개수를 누적합니다. 혹은 반대로 완제품부터 차례대로 내려옵니다.
    
    ### 효율성 문제 (시간 초과 및 중복)
    
    작성하신 `create` 함수는 재귀적으로 모든 경로를 탐색합니다. 만약 부품 간의 연결이 복잡해지면, 동일한 부품을 수천 번 중복 호출하게 되어 **시간 초과(TLE)**가 발생하거나, 중간 결과값을 저장(Memoization)하지 않으면 효율이 급격히 떨어집니다.
    
    ---
    
    ## 2. 위상 정렬을 이용한 정답 로직
    
    블로그들의 정답 코드를 분석해 보면 보통 다음과 같은 흐름을 따릅니다.
    
    ### 핵심 알고리즘 단계
    
    1. **진입 차수(Indegree) 계산:** 각 부품을 만드는 데 필요한 '선행 부품'의 개수를 기록합니다.
    2. **큐(Queue) 활용:** 진입 차수가 0인 부품(누구에게도 의존하지 않는 **완제품** 혹은 반대로 **기본 부품**)을 큐에 넣습니다.
    3. **DP 테이블 업데이트:** * 부품 $i$가 부품 $j$를 만드는 데 $k$개 필요하다면:
        - `dp[j][기본부품] += dp[i][기본부품] * k`
    4. **차수 감소:** 부품 $i$와 연결된 상위 부품들의 진입 차수를 1씩 줄이고, 0이 되면 큐에 넣습니다.
    
    ---
    
    ## 3. 작성하신 코드에서의 개선점
    
    현재 코드에서 가장 큰 문제는 **"중복 탐색"**입니다. 이를 해결하려면 **DP(Dynamic Programming)** 개념을 섞거나 위상 정렬을 써야 합니다.
    
    ### 위상 정렬 스타일로 수정할 경우 (의사 코드)
    
    C++
    
    # 
    
    `// 1. 역방향 그래프가 아니라 순방향(기본 -> 중간 -> 완제품)으로 저장
    // 2. indegree[i] == 0 인 기본 부품들을 큐에 삽입
    while (!q.empty()) {
        int curr = q.front(); q.pop();
        
        for (auto next : graph[curr]) {
            int target = next.first;
            int cost = next.second;
            
            // curr을 만드는 데 필요한 기본 부품 개수만큼 target에 곱해서 더함
            for (int i = 1; i <= n; i++) {
                counts[target][i] += counts[curr][i] * cost;
            }
            
            if (--indegree[target] == 0) q.push(target);
        }
    }`
    
    ### 요약하자면
    
    - **위상 정렬을 쓰는 이유:** 부품 간의 "계층 구조"가 명확하기 때문입니다.
    - **이점:** 모든 정점과 간선을 딱 한 번씩만 확인하므로 $O(V + E)$의 시간 복잡도로 해결 가능합니다. (작성하신 재귀 방식은 최악의 경우 지수 시간 복잡도가 될 수 있습니다.)
    
    **이 문제를 위상 정렬로 다시 구현해 보시겠어요? 아니면 제가 위 로직을 바탕으로 전체 코드를 다듬어 드릴까요?**
    

### 알고리즘 분류

- 다이나믹 프로그래밍
- 그래프 이론
- 방향 비순환 그래프
- 위상 정렬