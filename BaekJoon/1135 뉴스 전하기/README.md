# 1135 뉴스 전하기 (대실패)

# 문제 소개

[문제 링크](https://www.acmicpc.net/problem/1135)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 128 MB | 6361 | 3169 | 2569 | 50.294% |

## 문제

민식이는 회사의 매니저이다. 그리고, 민식이는 회사의 중요한 뉴스를 모든 직원에게 빠르게 전달하려고 한다. 민식이의 회사는 트리 구조이다. 모든 직원은 정확하게 한 명의 직속 상사가 있다. 자기자신은 그들 자기 자신의 직접 또는 간접 상사가 아니고, 모든 직원은 민식이의 직접 또는 간접적인 부하이다.

민식이는 일단 자기 자신의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 뉴스를 들은 후에, 각 부하는 그의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 이 것은 모든 직원이 뉴스를 들을 때 까지 계속된다. 모든 사람은 자신의 직속 부하에게만 전화를 걸 수 있고, 전화는 정확하게 1분 걸린다. 이때 모든 직원이 소식을 듣는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.

오민식의 사원 번호는 0이고, 다른 사원의 번호는 1부터 시작한다.

## 입력

첫째 줄에 직원의 수 N이 주어진다. 둘째 줄에는 0번 직원부터 그들의 상사의 번호가 주어진다. 0번 직원 (오민식)은 상사가 없기 때문에 -1이고, 나머지 직원 i의 상사 번호는 i보다 작거나 같은 음이 아닌 정수이다. N은 50보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 모든 소식을 전하는데 걸리는 시간의 최솟값을 출력한다.

## 예제 입력 1

```
3
-1 0 0
-> 2
```

## 예제 입력 2

```
5
-1 0 0 2 2
-> 3
```

## 예제 입력 3

```
5
-1 0 1 2 3
-> 4
```

## 예제 입력 4

```
24
-1 0 0 1 1 1 2 2 3 3 4 4 5 5 6 7 7 8 12 13 14 16 16 16
-> 7
```

---

# 초기 접근 방법

- 빠른 뉴스 전달 + 최솟값 = 뭔가 최단 경로 문제인가?
- 입력값이 작다는 특징 → 플로이드 워셜?
    - 라기 보다는 뭔가 매번 동적으로 확인하는 게 중요한 것 같다
- BFS + DP? -> 가장 깊은 레벨에서, 가장 많은 리프 노드를 갖고 있는 트리 먼저?

---

# 풀이 과정

- 변수 및 라이브러리 사용 이유
- 조건부 해석 이유

```cpp
손도 못댔다.
```

---

# 결과 & 근거

- 트리 문제이고 여러 방법으로 접근 했지만, 코드에 손도 대지 못했다…
- 정답은 트리 탐색 + 다이나믹 프로그래밍 (그리디 알고리즘) 이었다.
    - 가장 깊은 레벨에서, 가장 많은 리프 노드를 갖고 있는 트리 먼저 탐색해야 한다 라는 방법에는 접근했으나,,,
- https://kibbomi.tistory.com/232
- 골드 2 부터 많이 어려워 하는 것 같다.
    - 골드 3? 4 까지는 코드적으로 접근하면서 풀이하는 것 같은데,
    - 골드 2 정도 부터 벽을 느끼는 듯 하다.
- 제미나이의 답변
    
    ### 1. 코드 분석 및 상세 주석
    
    ```cpp
    #include <cstdio>
    #include <vector>
    #include <algorithm>
    
    using namespace std;
    
    // 각 노드의 자식 노드들을 저장할 인접 리스트
    vector<vector<int>> adj;
    int n;
    
    // DFS 함수: 현재 노드(cur)에서 모든 부하에게 뉴스를 전파하는 데 걸리는 최소 시간을 반환
    int dfs(int cur) {
        vector<int> v; // 자식들이 뉴스를 다 전파하는 데 걸리는 시간들을 담을 리스트
        int ret = 0;
        
        // 1. 자식 노드들을 끝까지 탐색 (Bottom-up 방식)
        for (int next : adj[cur]) {
            v.push_back(dfs(next)); // 각 자식의 서브트리가 완료되는 시간을 가져옴
        }
    
        // 만약 자식이 없다면(리프 노드), 자신은 0분 만에 전파 완료 가능하므로 바로 리턴될 준비를 함
        if (v.empty()) return 1;
    
        // 2. 그리디(Greedy) 핵심 전략:
        // 시간이 오래 걸리는 자식에게 먼저 전화를 걸어야 전체 시간이 단축됩니다.
        // 따라서 자식들이 보고한 시간을 내림차순(큰 순서대로)으로 정렬합니다.
        sort(v.begin(), v.end(), greater<int>());
    
        // 3. 시간 계산:
        // i번째로 전화를 거는 자식은 (전화 거는 순서 i분 + 그 자식이 전파하는 시간 v[i])이 걸립니다.
        // 그 중 가장 오래 걸리는 값이 현재 노드(cur)에서 발생하는 최종 소요 시간입니다.
        for (int i = 0; i < v.size(); ++i) {
            ret = max(ret, v[i] + i); 
        }
    
        // 결과에 1을 더하는 이유는 '나(부모)'에게 뉴스가 도달하는 시간 1분을 포함하는 개념입니다.
        return ret + 1;
    }
    
    int main() {
        scanf("%d", &n);
        adj.resize(n);
    
        for (int i = 0; i < n; ++i) {
            int p;
            scanf("%d", &p);
            if (p == -1) continue; // 루트 노드(민식이)는 상사가 없음
            adj[p].push_back(i);   // 부모 노드 p의 자식으로 i를 추가
        }
    
        // 루트 노드(0번)부터 시작
        // 최종 결과에서 1을 빼는 이유는 루트 노드는 전화를 받는 시간이 필요 없기 때문입니다.
        int ans = dfs(0);
        printf("%d", ans - 1);
    
        return 0;
    }
    ```
    
    ---
    
    ### 2. 핵심 로직 이해하기 (왜 이렇게 풀까요?)
    
    이 문제의 핵심은 "누구에게 먼저 전화를 걸 것인가?"입니다.
    
    1. 자식들의 소요 시간 파악:
        
        자식 A는 자기 부하들에게 다 돌리는 데 5분이 걸리고, 자식 B는 1분이 걸린다고 가정해 봅시다.
        
    2. **순서의 중요성**:
        - **A에게 먼저 걸면**: A에게 거는 시간(1분) + A가 돌리는 시간(5분) = **총 6분** 뒤 종료. 그 사이 B에게는 2분째에 전화를 걸 것이고 B는 1분 만에 끝나니 **총 3분** 뒤 종료. 결과적으로 전체는 **6분** 소요.
        - **B에게 먼저 걸면**: B에게 거는 시간(1분) + B가 돌리는 시간(1분) = **총 2분**. 그 다음 A에게 2분째에 걸면 A는 5분이 더 걸려 **총 7분** 소요.
    3. 결론 (Greedy):
        
        하위 전파 시간이 오래 걸리는 자식부터 먼저 전화를 돌려야 전체 시간이 최소가 됩니다.
        
    
    ### 3. 코드의 흐름 요약
    
    1. 트리를 구성합니다.
    2. `dfs(0)`을 호출하여 가장 아래쪽 노드(리프 노드)부터 위로 올라오며 시간을 계산합니다.
    3. 각 부모 노드는 자식들이 보내온 시간들을 **큰 순서대로 정렬**합니다.
    4. 정렬된 시간들에 전화 거는 순서(0, 1, 2...)를 더해 가장 큰 값을 찾습니다.
    5. 최종적으로 루트 노드에서 계산된 값에서 1을 빼서 출력합니다.
    
    블로그 코드에서는 `adj[cur].size() - 1`을 이용해 역순으로 계산하는 방식을 썼지만, 위 주석처럼 **내림차순 정렬 후 순서대로 더하는 방식**이 논리적으로 이해하기 훨씬 쉬우실 겁니다. (결과는 동일합니다.)
    

### 알고리즘 분류

- 다이나믹 프로그래밍
- 그리디 알고리즘
- 정렬
- 트리
- 트리에서의 다이나믹 프로그래밍