# 22968 균형

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/22968)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 1024 MB | 910 | 503 | 418 | 57.418% |

## 문제

이진 탐색 트리의 한 종류인 AVL Tree는 "높이 균형 성질"이라는 성질을 이용해 트리의 균형을 맞춘다.

또한, 높이 균형 성질을 만족하는 이진 탐색 트리는 전부 AVL Tree이다.

트리 T의 모든 내부 정점 v에 대해, v의 왼쪽 부트리와 오른쪽 부트리의 높이 차이가 1 이하일 때, T는 높이 균형 성질을 만족한다고 부른다.

[](https://upload.acmicpc.net/c803af4a-0d46-4d64-9cf7-34f551dd70c9/-/preview/)

위 그림에서, 왼쪽에 있는 트리는 모든 내부 정점의 왼쪽 부트리와 오른쪽 부트리의 높이가 동일하므로 AVL Tree이다.

가운데에 있는 트리는 5, 6, 8번 정점의 왼쪽 부트리와 오른쪽 부트리의 높이 차이는 1, 나머지 정점들은 0이므로 AVL Tree이다.

오른쪽에 있는 트리는 8번 정점의 왼쪽 부트리와 오른쪽 부트리의 높이 차이가 2이므로 AVL Tree가 아니다.

양의 정수 V가 주어지면, 최대 V개의 정점을 사용해서 만들 수 있는 AVL Tree의 최대 높이를 출력하는 프로그램을 작성하자.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1≤T≤1000)

둘째 줄부터 T개의 줄에 걸쳐 정점의 개수 V가 한 줄에 하나씩 주어진다. (1≤V≤1,000,000,000)

## 출력

총 T개의 줄에 걸쳐 정답을 출력한다.

각 테스트 케이스마다, 최대 V개의 정점으로 만들 수 있는 AVL Tree의 최대 높이를 출력한다.

## 예제 입력 / 출력

```
5
1
2
5
10
1000000000
```

```
1
2
3
4
42

```

---

# 초기 접근 방법

- 뭐가 있나….?
- AVL 성립 조건과 AVL 최소를 만드는 방법을 알면 쉬울 텐데…

---

# 풀이 과정

```cpp

#include <bits/stdc++.h>
using namespace std;

// https://www.acmicpc.net/problem/22968
// 양의 정수 V가 주어지면, 최대 V개의 정점을 사용해서 만들 수 있는 AVL Tree의 최대 높이를 출력하는 프로그램을 작성하자

int n;
vector<int> tree;

void input() {
    cin >> n;
    for (int i = 0; i<n; i++) {
        int a;
        cin >>a;
        tree.push_back(a);
    }
}

void solution() {
    // 정석 대로라면? 원래는 구현해야 하는 게 맞으나, 공식이 있는 것 같다

    /*
     * AVL 트리 성립 조건
     * 1. 이진 트리 이어야 한다.
     * 2. 좌, 우측 서브 트리 간 차이가 2 이상 나면 안된다.
     *
     */

    // 뭔가 알고리즘이 있나?
    // 수업 때 배운 게 얼핏 기억이 나서 더 헷갈린다.

    // dp [i] = i개로 만들 수 있는 AVL 트리의 높이? ==

}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
    input();
    solution();
}

```

---

# 결과 & 근거

- 뭐 코드적으로도 접근도 못했다.
    - 얼핏 AVL에 대해 공부 해보았으나, 기억이 나지 않아 헷갈렸다.
    - 이를 다른 알고리즘 이론으로 접할 수 있나? 라는 고민에서 시간을 많이 잡아먹은 듯 하다.
    - 예제 에서도 힌트를 줬는데… (10^9가 최대 42라는 것도 알려주었다.)
- 정답은 DP이긴 했다.
- 이론을 알고 있었는데 이를 정리하면 다음과 같다.
    - 높이가 F(h) 인 AVL를 만들기 위한 최소 노드 갯수를 h라 할 때
    - F(h) = F(h-1) + F(h-2)+1 이라는 공식이 성립된다.
        - 자식 트리는 적어도 h-1 이라는 높이를 갖고, 높이 차가 1 이어야 하므로 반대편 자식 트리는 높이가 h-2 이어야 한다.
    - 그렇게 해서 F(h) ≤ V 중에서 h가 최대인 걸 찾는다.
- https://please-amend.tistory.com/130
    - DP 푸는 방법과 공부가 아직도 덜 된 것 같다..

### 알고리즘 분류

- 다이나믹 프로그래밍