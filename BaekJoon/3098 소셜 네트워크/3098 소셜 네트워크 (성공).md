# 3098 소셜 네트워크 (성공)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/3098)

소셜 네트워크는 이제 우리 삶의 일부가 되어버렸다. 이러한 소셜 네트워크를 분석하는 김동규 석사과정은 흥미로운 현상을 발견했다. 바로 친구 관계의 수가 급속도로 증가한다는 것이다.

예로부터 우리의 조상님들은 "친구의 친구는 나의 친구"라고 했다. 사람들은 매일 조상님들의 말씀을 따르기 위해서 자신의 친구의 친구 목록을 확인하고, 이를 모두 자신의 친구로 추가한다. 친구 관계는 상대방이 수락을 해야 되고, 총 1일이 걸린다.

예를 들어, A와 B가 친구라면, A는 B가 어제 또는 그 이전에 만든 친구만 볼 수 있다.

모든 친구관계는 대칭, 양방향이다. 즉, A와 B의 친구라면, B도 A의 친구이다.

김동규가 분석하는 소셜 네트워크에서는 한 번 친구 관계가 맺어졌으면, 이것을 깰 수 없다.

사람의 수와 지금 친구 관계가 주어졌을 때, 모든 사람이 서로 친구가 되는데 걸리는데 며칠이 걸리는지 구하는 프로그램을 작성하시오. 또한, 매일 매일 새로운 친구 관계가 얼마나 생기는지 구해서 출력하시오.

**입력** 

첫째 줄에 사람의 수 N과 처음 친구 관계의 수 M이 주어진다. (1 ≤ N ≤ 50, 1 ≤ M ≤ N*(N-1)/2)

둘째 줄부터 M개의 줄에는 두 정수 A와 B가 주어진다. (1 ≤ A ≤ N, 1 ≤ B ≤ N, A < B). 이것은 A와 B가 친구라는 것을 의미한다. 항상 모든 사람이 서로 친구가 될 수 있는 경우만 입력으로 주어진다.

**출력**

첫째 줄에 모든 사람이 서로 친구가 되는데 며칠이 걸리는지 출력한다. 이 값을 K라고 하자.

다음 K개의 줄에는 몇 명의 새로운 친구 관계가 생기는지, 첫째날부터, K번째 날까지 한 줄에 하나씩 출력한다.

---

# 초기 접근 방법

- 뭔가 친구 관계를 그래프 형식의 2차원 배열이나, 연결 리스트 형식으로 표현하고자 한다.
    - 연결 리스트 형식을 더 선호해서 ㅎㅎ
- 친구 추가 요청 후 수락 까지는 하루가 걸림.
    - 반복문을 통해 날짜를 증가시켜가며 검사하는 로직을 짜는 게 나을 듯…?
    - 데이터 수가 작아서 위 방식으로 작성해도 시간 제한 내에 작성 가능할 듯 하다.

---

# 풀이 과정

```cpp
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int n, m;

int table[52][52]; // 친구 관계 2차원 배열, 0과 1로 관계 표현

vector<vector<int> > friends; // 친구 관계 그래프
vector<int> make_friend_each_day; // 각 날짜 별 친구 관계 형성 수

queue<pair<int, int> > update; // 업데이트 해야 하는 친구 관계

/**
 * 복잡해보이지만, 친구 관계를 만드는 함수.
 * @return null;
 */
void update_friends() { 
    int make_friend_cnt = 0;
    while (!update.empty()) {
        pair<int, int> value = update.front();

        if (table[value.first][value.second] == 1 || table[value.second][value.first] == 1) {
            update.pop(); // 이미 친구 관계 형성 된 경우 skip
            continue;
        }

        table[value.first][value.second] = 1, table[value.second][value.first] = 1;
        friends[value.first].push_back(value.second), friends[value.second].push_back(value.first);
        update.pop(),  make_friend_cnt++;
    }
    make_friend_each_day.push_back(make_friend_cnt);
}

int make_friends() {
    int day = 0;
    while (true) {
        bool isMakingFriend = false;

        for (int i = 1; i <= n; i++) {
            int size = friends[i].size();

            if (size == n - 1) continue; // 이미 모든 관계 형성이 된 경우

            for (int j = 0; j < size; j++) { // make friend!

                int cur_freind = friends[i][j]; // 현 주인공의 친구에 대해
                for (int k = 0; k < friends[cur_freind].size(); k++) { // 현 주인공의 친구의 친구에 대해

                    if (i == friends[cur_freind][k])  continue; // 내 자신은 skip

                    if (table[i][friends[cur_freind][k]] != 1 || table[friends[cur_freind][k]][i] != 1) { // 현 주인공의 친구의 친구 찾기.
                        update.push({i, friends[cur_freind][k]});
                        isMakingFriend = true; // 친구 관계 아닌 저너머 친구를 친구로.
                    }
                }
            }
        }
        if (!isMakingFriend) {
            return day;
        }

        // 대신 업데이트는 날짜가 지난 이후 한 번에 친추 요청 수락이 되어야 한다.
        day++, update_friends();
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    cin >> n >> m;

    friends = vector<vector<int> >(n + 1);

    int a, b;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        friends[a].push_back(b), friends[b].push_back(a);
        table[a][b] = 1, table[b][a] = 1;
    }

    cout << make_friends() << '\n';
    for (int i: make_friend_each_day) {
        cout << i << '\n';
    }
    return 0;
}

```

- 친구 추가 요청은 하루 뒤에 업데이트 되므로, 큐를 사용하여 친구 관계를 날짜가 지나기 직전 업데이트 해주었다.
    - 큐를 썼지만, 리스트 형 자료 구조 아무거나 써도 상관 없다.
- 친구 관계 탐색을 위해 2차원 벡터와 2차원 배열을 동시에 썼다.
    - 형성 관계에 대해서만 for 문을 돌리고 싶어서 2차원 벡터로 사용하면서
    - 2차원 배열을 두어 굳이 벡터 내 find 함수가 아닌, O(1) 시간 안에 검증을 하고 싶었다… (DFS의 visit 처럼)
- 사실 데이터 수가 적어 2차원 배열만 써도 상관은 없을 것 같다.

---

# 결과 & 근거

- 진짜 오랜만에 한 번에 성공했다.골드 5 치고는 쉬운 문제였던 것? 같다.
- 사실 문제가 SNS 네트워크 라고 너무 노골적으로 표현해서 그래프 구조 알고리즘임을 눈치챘다
- 그래프 탐색 속에서 업데이트 를 나중에 해주어야 한다는 것이 약간의 변형? 이었던 것 같다.