# 1262, 알파벳 다이아몬드 (실패)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/1262)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 128 MB | 1483 | 525 | 454 | 38.055% |

알파벳 다이아몬드는 정수 길이의 마름모가 여러 개 누적되는 모양이다. 각각의 마름모는 하나의 알파벳 소문자로 그리며, a로 시작해서 z로 끝난다. (가운데에서부터) 그리고, z 이후에는 다시 a로 시작한다.

알파벳 다이아몬드는 다음과 같이 생겼다.

동호는 이런 알파벳 다이아몬드를 타일로 만들어서, 방 바닥을 타일로 모두 채웠다. 예를 들어, N = 5인 아스키 다이아몬드를 세로 크기가 17, 가로 크기가 46인 방에 채운다면 다음과 같은 모양이 된다.

```java
....e........e........e........e........e.....
...ede......ede......ede......ede......ede....
..edcde....edcde....edcde....edcde....edcde...
.edcbcde..edcbcde..edcbcde..edcbcde..edcbcde..
edcbabcdeedcbabcdeedcbabcdeedcbabcdeedcbabcdee
.edcbcde..edcbcde..edcbcde..edcbcde..edcbcde..
..edcde....edcde....edcde....edcde....edcde...
...ede......ede......ede......ede......ede....
....e........e........e........e........e.....
....e........e........e........e........e.....
...ede......ede......ede......ede......ede....
..edcde....edcde....edcde....edcde....edcde...
.edcbcde..edcbcde..edcbcde..edcbcde..edcbcde..
edcbabcdeedcbabcdeedcbabcdeedcbabcdeedcbabcdee
.edcbcde..edcbcde..edcbcde..edcbcde..edcbcde..
..edcde....edcde....edcde....edcde....edcde...
...ede......ede......ede......ede......ede....

```

타일 하나의 위치는 행과 열을 이용해 표현한다. 행은 위에서부터 0행, 1행 이고, 열은 왼쪽부터 0열, 1열이다.

동호는 자신의 방의 어떤 부분 직사각형에 쓰여 있는 알파벳이 궁금해졌다. N이 주어지고, 동호가 알고 싶어하는 직사각형의 왼쪽 위 좌표 (R1, C1)와 오른쪽 아래 좌표 (R2, C2)가 주어질 때, 그 직사각형에 쓰여 있는 알파벳을 출력하는 프로그램을 작성하시오. 동호의 방의 크기는 무한하다. (x, y)는 x행 y열을 의미한다.

**입력**: 첫째 줄에 5개의 정수 N, R1, C1, R2, C2가 주어진다.

**출력**: (R2 - R1 + 1)줄에 (C2 - C1 + 1)개의 문자를 출력한다.

**제한**

- 1 ≤ N ≤ 20,000
- 0 ≤ R1 ≤ R2 ≤ 20,000
- 0 ≤ C1 ≤ C2 ≤ 20,000
- 0 ≤ (R2 - R1 + 1) × (C2 - C1 + 1) ≤ 40,000

---

# 초기 접근 방법

- 일단 방의 크기는 무한하다.
- 어떠한 방법으로 접근해야 할까?
- 저 무한한 방의 크기를 만드는 게 중요 (N이 최대 2만.)
    - (R1, C1), (R2, C2)에 대해 for 문 출력이라, 찾는 건 어렵지 않다.

빠르게 생각해본 알고리즘 전체 로직

1. 일단 테스트 데이터 입력
2. 방의 최대 데이터는 (R2, C2)에 결정된다. 그렇기에 이를 기준으로 방을 만든다.
3. 이중 for 문을 통해 직사각형을 출력한다.

방을 채우는 방법

1. 타일을 만든다.
    1. 타일의 크기는 (2n-1)^2
    2. 타일 만드는 것도 귀찮네
2. 일단 2차원 배열을 만들어 || Vector…?
3. 방을 채워야 하는데 어떻게…?
    - 일일히 반복문을 통한 fill은 어찌저찌 될 거 같긴 하다. 그래봤자 O(n) 이니까
    - 뭔가 특정 배열 범위 = 1 타일 이런 게 되나?

---

# 풀이 과정

- 사실 아스키 코드적으로 접근하면 쉽다.
- 또한 반복적인 패턴이므로 다른 알고리즘 형식 없이 단순 구현으로도 풀 수 있다.

```cpp
#include <algorithm>
#include <iostream>
#include <valarray>
#include <vector>

/**
 * 1262, Alphabet Diamond
 * https://www.acmicpc.net/problem/1262
 */

using namespace std;

int N, R1, C1, R2, C2;

vector<vector<char>> tile;
vector<int> arr;

void makeTile() {
    // 타일은 무조건 홀수 * 홀수, 20,000 * 20,000
    tile = vector(2 * N - 1, vector<char>(2 * N - 1));

    // ACEII: 97 ~
    // 반 ~ 우측 끝 까지 만들고 뒤집기?

    for (int i = 0; i<N; i++) {
        char pos = 96 + N - i;
        cout << "pos: " << pos << endl;
        for (int j = 0; j<=i; j++) { // 범위 오류!!!
            // 알파벳 채우기
            tile[i][N/2+j] = pos - j;
        }
        for (int j = i + 1; j < N; j++) {
            // . 채우기
            tile[i][N/2+j] = '.';
        }
        for (int j = N / 2; j < N; j++) {
            // 뒤집기
            tile[i][N / 2 - j] = tile[i][j];
        }

        printf("pos[%d]: ", i);
        for (int j = 0; j < tile[i].size(); j++) {
            cout << tile[i][j];
        }
        cout << endl;
    }

    for (int i = 0; i < tile.size(); i++) {
        for (int j = 0; j < tile[i].size(); j++) {
            cout << tile[i][j];
        }
        cout << endl;
    }
}

void printRoom() {
    for (int i = R1; i <= C1; i++) {
        for (int j = R2; j <= C2; j++) {
            cout << tile[i][j];
        }
        cout << '\n';
    }
}

void mySolution () {
    makeTile();
    printRoom();
}

void correctsolution () {
    for (int i = R1; i <= R2; i++) {
        for (int j = C1; j<=C2; j++) {

            // 현 i와 j에 대해 타일 크기 안에 있는지 확인
            int temp = abs(i % (2*N-1)- N + 1) + abs(j % (2*N-1)- N + 1);

            if (temp > N-1) cout << '.'; // 나간 경우 .으로
            else {
                char alpha = 'a' + temp%26;
                cout << alpha;
            }
        }
        cout << '\n';
    }
}

int main() {
    ios_base::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    cin >> N >> R1 >> C1 >> R2 >> C2;

    // mySolution();
    correctsolution();

    return 0;
}
```

---

# 결과 & 근거

- 다른 접근 방법 없이 단순 구현으로 풀 수 있을 거라 생각해서 30분 남짓했을 때 집중 구현을 들어가긴 했으나, 타일 채우는 데에서 실패했다.
- 아스키코드 식 접근, 반복적인 패턴에 대해 너무 복잡하게 생각했던 것 같다….
- 전체 채울 필요도 없이 원했던 직사각형에 집중하면 되는 문제였다.