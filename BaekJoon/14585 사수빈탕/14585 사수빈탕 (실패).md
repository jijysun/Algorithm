# 14585 사수빈탕 (실패)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/14585)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 64 MB | 1865 | 663 | 520 | 40.816% |

## 문제

수빈이는 좌표평면 위에 앉아있다. "나는 좌표평면이 너무 좋아!!" 라고 수빈이가 말했다. 좌표평면에는 N개의 사탕바구니가 있고, 각 사탕 바구니에는 M개의 사탕이 있다. 각 사탕 바구니는 (x1, y1), (x2, y2), …, (xn, yn)에 있고, 수빈이는 (0, 0)에 있다.

오늘은 날씨가 덥다. 따라서 시간이 1만큼 지날 때마다 사탕이 남아 있는 모든 사탕바구니에서 사탕은 한 개씩 녹아서 없어진다. 수빈이는 매우 배가 고프기 때문에, 사탕바구니에 있는 사탕을 순식간에 모두 먹을 수 있다. 수빈이가 1만큼 움직일 때, 시간은 1만큼 지나간다. 수빈이는 위쪽 (y-좌표가 늘어나는 방향) 또는 오른쪽 (x-좌표가 늘어나는 방향)으로만 움직일 수 있다.

수빈이가 먹을 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 M이 주어진다.

둘째 줄부터 N개의 줄에 사탕 바구니의 위치 xi, yi가 주어진다. (0 ≤ N ≤ 300, 1 ≤ M ≤ 1,000,000, 0 ≤ xi, yi ≤ 300)

사탕 바구니의 위치는 중복되지 않으며, (0, 0)에는 사탕이 없다.

## 출력

수빈이가 먹을 수 있는 사탕의 최대 개수를 출력한다.

---

# 초기 접근 방법

- 그래프 상에서 녹아 없어지는 사탕을 최대한 많이 먹어야 한다.
    - 그리디? 최단 경로 알고리즘?
- 하지만 누적합 같은 느낌이면서, 이전 값을 사용하는 경우 (이전 좌표에서 다음 좌표로 이동할 수 있는 지)이다
    - dp?

---

# 풀이 과정

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 * https://www.acmicpc.net/problem/14585
 * sasubintang
 */

int n, m;

// int arr [][];

vector<pair<int, int>> arr2, arr3;

int dp [301][301];

bool compare1(pair<int, int> a, pair<int, int> b) {
    if (a.first == b.first) {
        return a.second < b.second;
    }
    return a.first < b.first;
}

bool compare2(pair<int, int> a, pair<int, int> b) {
    if (a.second == b.second) {
        return a.first < b.first;
    }
    return a.second < b.second;
}

void input() {
    cin >> n >> m;

    // arr = int(n)(2);
    /*arr2 = vector<pair<int, int>> (n);
    arr3 = vector<pair<int, int>> (n);*/

    for (int i = 0; i<n; i++) {
        // cin >> arr[i][0] >> arr[i][1];
        int a, b;
        cin >> a >> b;

        arr2.push_back({a, b});
        arr3.push_back({a, b});

        dp[a][b] = 1;

    }
    // sort(arr2.begin(), arr2.end(), compare1);
    sort(arr3.begin(), arr3.end(), compare2);

    /*for (int i = 0; i<n; i++) {
        printf("%d %d \n", arr2[i].first, arr2[i].second);
    }

    printf("----\n");

    for (int i = 0; i<n; i++) {
        printf("%d %d \n", arr3[i].first, arr3[i].second);
    }*/

}

void solution() {
    // 먹을 수 있는 최대 사탕 개수...
    // 최단 경로? 그리디?

    // 풀이가 잘못됨
    // 동일 선상에서 더 좋은, 가까운 애를 선택해야 함. -> dp!!!!!!!!

    // 0.0 부터 시작. 대신 1 움직일 때 마다 사탕 1개씩 감소

    pair<int, int> pos = {0, 0};
    int first_m = m,  arr2_max=0, arr3_max=0, arr_max;

    /*for (int i = 0; i<n; i++) {
        if (pos.first <= arr2[i].first &&pos.second <= arr2[i].second) {
            // m= m - arr2[i].first - arr2[i].second;
            m= m- abs(pos.first-arr2[i].first) - abs(pos.second- arr2[i].second);
            arr2_max+=m;
            pos.first = arr2[i].first, pos.second = arr2[i].second;
            // printf("goto %d, %d, eat %d\n", arr2[i].first, arr2[i].second, m);
        }
        else {
            break;
        }
    }
    m = first_m;

    pos = {0,0};
    for (int i = 0; i<n; i++) {
        if (pos.first <= arr3[i].first &&pos.second <= arr3[i].second) {
            m= m-abs(pos.first-arr3[i].first)-abs(pos.second- arr3[i].second);
            arr3_max+=m;
            pos.first = arr3[i].first, pos.second = arr3[i].second;
            // printf("goto %d, %d, eat %d\n", arr3[i].first, arr3[i].second, m);
            // m = m - arr3[i].first - arr3[i].second;
        }
        else {
            break;
        }
    }
    m = first_m;

    // printf("arr2: %d\narr3: %d\n", arr2_max, arr3_max);
    cout << max (arr2_max, arr3_max) << '\n';*/

    for (int i = 0; i<n; i++) {
        if () { // 갈 수 없는 경우
            break;
        }
        else {

            for (int i = pos.first; i<=300; i++) { // x 동일 선상에서 제일 가까운 애 찾기.

            }
            for (int i = pos.second; i<=300; i++) { // y 동일 선상에서 제일 가까운 애 찾기.

            }

            arr2_max = min(abs()+abs(), abs()); // 동일 선상 중 가까운 애...?
        }
    }

}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input();

    solution();
}
```

- 그냥 누적합 방식, dp 방식 모두 도전해보았지만…

---

# 결과 & 근거

- 마지막, 거의 20분 남겨두고 dp임을 알아챘지만, dp의 원초적인 풀이까지는 접근하지 못했다.
    - 아직 DP 가 너무 생소한 것도 없지 않아 있는 듯 하다.
- 뭔가 그래프 상에서 최대 개수 구하기 라는 탓에 최단 경로나, 그래프 탐색으로 착각했다..
- 풀이 참고: https://pingu0130.tistory.com/151

### 알고리즘 분류

- 다이나믹 프로그래밍