# 1464 뒤집기 3 (대실패)

# 문제 소개

[문제 사이트 링크](https://www.acmicpc.net/problem/1464)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 128 MB | 2467 | 1002 | 795 | 43.996% |

## 문제

세준이는 어떤 문자열 S를 뒤집으려고 한다. 문자열을 뒤집는 방법은 문자열의 길이를 N이라고 하자. i만큼을 뒤집는다는 소리는 그 문자열의 처음부터 정확하게 i개의 문자를 역순으로 뒤집는 것이다. 세준이는 1부터 N까지 수를 차례대로 생각한다. 그리고, 뒤집을지 안 뒤집을지 선택할 수 있다.

예를 들어, S="BCDAF" 이고, 세준이가 길이 1만큼을 뒤집지 않고, 길이 2만큼도 뒤집지 않고 세준이가 길이 3만큼을 뒤집는다고 하면 문자열은 DCBAF가 된다. 다시 여기서 4만큼 뒤집으면 ABCDF가 된다. 그리고, 마지막으로 길이를 5만큼 뒤집지 않으면 주어진 문자열 S를 사전순으로 가장 앞서게 만들 수 있다.

문자열 S가 주어졌을 때, 위와같은 뒤집기 방법으로 만들 수 있는 문자열 중 사전순으로 제일 앞서는 것을 출력하시오.

## 입력

첫째 줄에 문자열 S가 주어진다. 문자열의 길이는 최대 50이다. 알파벳 대문자만 들어온다.

## 출력

첫째 줄에 사전순으로 가장 앞서는 정답을 출력한다.

---

# 초기 접근 방법

처음부터 i 만큼 문자를 역순으로 뒤집는다. 대신 1~문자열 길이 만큼 무조건 뒤집거나, 안뒤집어야 한다.

해서 경우의 수 중 문자열 사전순으로 제일 앞에 있는 문자열을 출력한다

- 엄청난 경우의 수가 존재한다 → 브루트 포스, 그리디, DP 등등…
- 또한 해당 경우의 수가 사전순으로 제일 앞에 있어야 한다 → 그리디 알고리즘?

---

# 풀이 과정

- 뭔가 전체 데이터 수가 작아 그냥 뒤집는 거 판단해도 되지 않을까? 라는 생각이다.

대신 문자열 사전순 판단은 어떻게?

- 계속해서 문자열 만들어가면서 일일히 비교?

```cpp
#include <bits/stdc++.h>
using namespace std;

/*
 * https://www.acmicpc.net/problem/1464
 * reverse 3
 */

string s;
string new_String;

void input() {
    cin >> s;
}

void solution() {

    for (int i = 1; i<=s.size(); i++) { // 전체 문자열 길이 만큼

        for (int j = 0; j<s.size(); j++) { // 문자열 순회, index

            new_String = s;
            // 뒤집지 말 지 판단

            printf("%d ~ %d 사이를 바꿉니다, ", j, j+i);

            for (int k=j; k<j+i; k++) { // 문자열 뒤집기

                swap(new_String[k], new_String[i+j-k]);
                /*char temp = new_String[k];
                new_String[k] = new_String[i+j-k];
                new_String [i+j-k] = temp;*/
            }

            printf("%s <-> %s\n\n", s.c_str(), new_String.c_str());

            if (s.compare(new_String)>0) {
                s = new_String;
            }
        }

    }

}

int main() {
    ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);

    input();

    solution();
}
```

- 접근 방법이 너무 떠오르지 않아 10분 남짓하고 일단 중지했다.
- 지금 알고리즘은 무조건 뒤집어 본 문자열이 작을 때, 해당 문자열을 선택한다.
    - 하지만 문제는 뒤집지 않을 수도 있고, 이에 대해 엄청난 경우의 수를 만든다.

---

# 결과 & 근거

- 그리디 알고리즘인 건 알겠는데, 해당 알고리즘에 대한 충분한 공부를 하지 않아 대차게 실패했다.
    - 찾아본 결과, 주어질 수 있는 데이터 수가 작아 브루트 포스 알고리즘으로도 풀 수 있다….
- 문제를 잘 못 이해한 것도 있다.
    - 무조건 첫 번째 문자 부터 뒤집어야 한다는 걸 깜빡하고 이해하였다.
- 참고 자료 → https://thought-process-ing.tistory.com/280
- 이건 나중에 다시 복습해야겠다.